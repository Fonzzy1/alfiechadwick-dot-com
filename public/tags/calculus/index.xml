<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Calculus on Alfie Chadwick</title>
    <link>/tags/calculus/</link>
    <description>Recent content in Calculus on Alfie Chadwick</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 12 Jan 2024 00:00:00 +0000</lastBuildDate><atom:link href="/tags/calculus/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Making my ODE solver solve ODEs</title>
      <link>/2024/01/12/making-my-ode-solver-solve-odes/</link>
      <pubDate>Fri, 12 Jan 2024 00:00:00 +0000</pubDate>
      
      <guid>/2024/01/12/making-my-ode-solver-solve-odes/</guid>
      <description>After writing out the last post where I wrote out a python library for using an improved version of Euler&amp;rsquo;s method to solve ODEs. But so far, we haven&amp;rsquo;t been solving ODES, instead we have just been taking an initial value and iterating it over the length of a domain. To To make the ODE estimator work, we need to ensure that the conditions of the ODE are met at each step.</description>
    </item>
    
    <item>
      <title>Making a Python Library to solve differential Equations</title>
      <link>/2023/12/29/making-a-python-library-to-solve-differential-equations/</link>
      <pubDate>Fri, 29 Dec 2023 00:00:00 +0000</pubDate>
      
      <guid>/2023/12/29/making-a-python-library-to-solve-differential-equations/</guid>
      <description>After having the initial idea I wrote up in a previous post, I thought it was a good idea to turn it into a python library so that I can use it as part of my other projects.
It also gives me a chance to see numerically how well the new method works compared to the Euler method.
First Steps So in the last post I set out the method such that:</description>
    </item>
    
    <item>
      <title>Using Taylor Series to Improve the Euler Method</title>
      <link>/2023/12/18/using-taylor-series-to-improve-the-euler-method/</link>
      <pubDate>Mon, 18 Dec 2023 00:00:00 +0000</pubDate>
      
      <guid>/2023/12/18/using-taylor-series-to-improve-the-euler-method/</guid>
      <description>Euler&amp;rsquo;s Method Euler&amp;rsquo;s method is a classic way of approximating first-order differential equations. In short, it uses the derivative of a function and starting condition to estimate the value of the function a short distance from the starting point.
This is commonly written as:
Where is the error created by the approximation.
Higher Order ODEs Generalizing Euler&amp;rsquo;s method to higher order ODEs is pretty easy. All you have to do is think of the ODE as a vector with each entry being the next derivative of the function.</description>
    </item>
    
    <item>
      <title>Modeling Drug Use in Communities</title>
      <link>/2023/10/22/modeling-drug-use-in-communities/</link>
      <pubDate>Sun, 22 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>/2023/10/22/modeling-drug-use-in-communities/</guid>
      <description>Preface This was written as a University project but I&amp;rsquo;m pretty happy with how it turned out.
Big thanks to Kevin Dai and Chrysovalantis Thomopoulos who worked with me on this throughout the semester.
Introduction Drugs are chemical substances with physiological effects. Some drugs like opioids, cannabis, alcohol, nicotine, cocaine, methamphetamine, or heroin are of concern to policymakers. Widespread drug abuse in a community can be a burden to society and the economy.</description>
    </item>
    
    <item>
      <title>Optimising the settings for the ODE solver</title>
      <link>/1/01/01/optimising-the-settings-for-the-ode-solver/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/1/01/01/optimising-the-settings-for-the-ode-solver/</guid>
      <description>import numpy as np import math import matplotlib.pyplot as plt import numpy as np import mplcatppuccin import matplotlib as mpl import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D mpl.style.use(&amp;#34;macchiato&amp;#34;) def expanded_euler(dims, h): step_matrix = np.zeros((dims, dims)) for i in range(dims): for j in range(i, dims): # Is 1, and h at j-i =0, 1 respectively step_matrix[i, j] = h ** (j - i) / math.factorial(j - i) expanded_matrix = add_x_and_1(step_matrix, h) return expanded_matrix def add_x_and_1(original_matrix, h): new_size = len(original_matrix) + 2 new_matrix = np.</description>
    </item>
    
  </channel>
</rss>
