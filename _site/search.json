[
  {
    "objectID": "content/post/taylor-series/post-3.html",
    "href": "content/post/taylor-series/post-3.html",
    "title": "Making my ODE solver solve ODEs",
    "section": "",
    "text": "After writing out the last post where I wrote out a python library for using an improved version of Euler’s method to solve ODEs. But so far, we haven’t been solving ODES, instead we have just been taking an initial value and iterating it over the length of a domain. To To make the ODE estimator work, we need to ensure that the conditions of the ODE are met at each step."
  },
  {
    "objectID": "content/post/taylor-series/post-3.html#but-why-does-this-matter",
    "href": "content/post/taylor-series/post-3.html#but-why-does-this-matter",
    "title": "Making my ODE solver solve ODEs",
    "section": "But Why Does This Matter",
    "text": "But Why Does This Matter\nThe reason that we want to reframe ODEs in this way is because of the following fact:\nFor all constant-linear ODEs, we can express the ODE as a matrix such that applying it to any point in the vector space would map any point to a valid point on the curve defined by the ODE\n\nLooking at the equations above, these matrices (\\(T\\)) are:\n\nSimple Harmonic Motion: \\[T = \\begin{bmatrix}\n1 & 0 & 0 & 0 & 0\\\\\n0 & 1 & 0 & 0 & 0\\\\\n0 & 0 & 1 & 0 & 0\\\\\n0 & 0 & 0 & 1 & 0\\\\\n0 & 0 & -\\omega^2 & 0 & 0\\\\\n\\end{bmatrix}\n\\]\nRadioactive Decay: \\[T = \\begin{bmatrix}\n1 & 0 & 0 & 0\\\\\n0 & 1 & 0 & 0\\\\\n0 & 0 & 1 & 0\\\\\n0 & 0 & -\\lambda & 0\\\\\n\\end{bmatrix}\\]\nRC Circuit Equation: \\[T = \\begin{bmatrix}\n1 & 0 & 0 & 0\\\\\n0 & 1 & 0 & 0\\\\\n0 & 0 & 1 & 0\\\\\n0 & 0 & \\frac{-1}{RC} & 0\\\\\n\\end{bmatrix}\\]\nDamped Harmonic Oscillator: \\[T = \\begin{bmatrix}\n1 & 0 & 0 & 0 & 0\\\\\n0 & 1 & 0 & 0 & 0\\\\\n0 & 0 & 1 & 0 & 0\\\\\n0 & 0 & 0 & 1 & 0\\\\\n0 & 0 & -\\omega^2 & -2\\gamma & 0\\\\\n\\end{bmatrix}\\]\nHeat Equation (One-Dimensional): \\[T = \\begin{bmatrix}\n1 & 0 & 0 & 0 & 0\\\\\n0 & 1 & 0 & 0 & 0\\\\\n0 & 0 & 1 & 0 & 0\\\\\n0 & 0 & 0 & 1 & 0\\\\\n0 & 0 & 0 & \\frac{1}{\\alpha} & 0\\\\\n\\end{bmatrix}\\]\nExponential Growth or Decay: \\[T = \\begin{bmatrix}\n1 & 0 & 0 & 0\\\\\n0 & 1 & 0 & 0\\\\\n0 & 0 & 1 & 0\\\\\n0 & 0 & k & 0\\\\\n\\end{bmatrix}\\]"
  },
  {
    "objectID": "content/post/taylor-series/post-3.html#using-these-to-fit-odes",
    "href": "content/post/taylor-series/post-3.html#using-these-to-fit-odes",
    "title": "Making my ODE solver solve ODEs",
    "section": "Using these to fit ODEs",
    "text": "Using these to fit ODEs\nNow that we can express the ODEs in the form of a matrix, we can implement these matriexies in the ODE solver package to make the solution fit the ode. It’s important here to note that I’ve diverted from my old definitions of \\(Y\\) here, where the first element of the vector is \\(y(x)\\).\nTo make a step in the approximation we use the following equation:\n\\[ \\begin{bmatrix}\n1 \\\\\nx+h \\\\\ny(x+h)\\\\\ny'(x+h)\\\\\ny''(x+h)\\\\\n...\\\\\ny^{n}(x+h)\\\\\n\\end{bmatrix} =  S \\cdot \\begin{bmatrix}\n1 \\\\\nx\\\\\ny(x)\\\\\ny'(x)\\\\\ny''(x)\\\\\n...\\\\\ny^{n}(x)\\\\\n\\end{bmatrix}\n\\epsilon \\]\nWhere \\(S\\) is: \\[ \\begin{bmatrix}\n1 & 0 & 0 & 0 & 0 & ... & 0 \\\\\nh & 1 & 0 & 0 & 0 & ... & 0 \\\\\n0 & 0 & 1 & \\frac{h}{1!} & \\frac{h^2}{2!} &  ... & \\frac{h^n}{n!}\\\\\n0 & 0 & 0 & 1 & \\frac{h}{1!} &  ... & \\frac{h^{n-1}}{(n-1)!}\\\\\n0 & 0 & 0 & 0 & 1 &  ... & \\frac{h^{n-2}}{(n-2)!}\\\\\n... & ... & ... & ... &  ... & ...\\\\\n0 & 0 & 0 & 0 & 0 &  ... & 1\\\\\n\\end{bmatrix}\\]\nWhen making this step, the error in the approximation will move the point away from the plane that contains all valid solutions to the ODE, and therefore we will have to snap it back using one of the transformation matrices (\\(T\\)).\nImplementing this method in our python library:\n\ndef expanded_euler(dims, h):\n    step_matrix = np.zeros((dims, dims))\n    for i in range(dims):\n        for j in range(i, dims):\n            # Is 1, and h at j-i =0, 1 respectively\n            step_matrix[i, j] = h ** (j - i) / math.factorial(j - i)\n    expanded_matrix = add_x_and_1(step_matrix, h)\n    return expanded_matrix\n\n\ndef add_x_and_1(original_matrix, h):\n    new_size = len(original_matrix) + 2\n    new_matrix = np.zeros((new_size, new_size), dtype=original_matrix.dtype)\n\n    # Set the 2x2 top left matrix\n    new_matrix[0:2, 0:2] = [[1, 0], [h, 1]]\n\n    # Copy the original matrix to the bottom right of the new matrix.\n    new_matrix[2:, 2:] = original_matrix\n    return new_matrix\n\n\ndef linear(y, step_matrix_generator, transformation_matrix, steps=10, h=0.1):\n    dims = len(y) - 2\n    step_matrix = transformation_matrix @ step_matrix_generator(dims, h)\n    output_list = []\n\n    y_n = y.copy()\n    i = 0\n    while i &lt; steps:\n        y_n = step_matrix @ y_n\n        output_list.append(y_n)\n        i += 1\n\nBind this machinery together, and you get a tool capable of tackling the initial example of \\(y' = 2x\\) passing through the point (0,0):\n\nimport numpy as np\nimport math\n\n\nclass Solution:\n    def __init__(self, input_list: list):\n        solution_list = sorted(input_list, key=lambda x: x[1])\n\n        dims = len(solution_list[0]) - 2\n        self.x = np.array([x[1] for x in input_list])\n\n        value_lists = [[] for _ in range(dims)]\n\n        for v in input_list:\n            for i in range(dims):\n                value_lists[i].append(v[i + 2])\n\n        for i in range(dims):\n            self.__dict__[f\"y_{i}\"] = np.array(value_lists[i])\n\n    def interpolate(self, x, y_n):\n        \"\"\"\n        allows you to get any value from the solution by interpolating the points\n\n        \"\"\"\n        y_values = self.__dict__[f\"y_{y_n}\"]\n\n        x_max_index = np.where(self.x &gt;= x)[0][0]\n        x_min_index = np.where(self.x &lt;= x)[0][-1]\n\n        x_at_x_max = self.x[x_max_index]\n        x_at_x_min = self.x[x_min_index]\n\n        y_at_x_max = y_values[x_max_index]\n        y_at_x_min = y_values[x_min_index]\n\n        slope = (y_at_x_max - y_at_x_min) / (x_at_x_max - x_at_x_min)\n\n        value = y_at_x_min + slope * (x - x_at_x_min)\n        return value\n\ndef linear(y, step_matrix_generator, transformation_matrix, steps=10, h=0.1):\n    dims = len(y) - 2\n    step_matrix = transformation_matrix @ step_matrix_generator(dims, h)\n    output_list = []\n\n    y_n = y.copy()\n    i = 0\n    while i &lt; steps:\n        y_n = step_matrix @ y_n\n        output_list.append(y_n)\n        i += 1\n\n    return Solution(output_list)\n\n\ninit_y = [1,0,0,0] #[1,x,y,y']\ntransformation_matrix = np.array([\n   [ 1,0,0,0 ],\n   [ 0,1,0,0 ],\n   [ 0,0,1,0 ],\n   [ 0,2,0,0 ]\n])\nsolution = linear(\n    init_y,\n    expanded_euler,\n    transformation_matrix,\n    steps=100, h=0.01)\n\n\nplt.plot(solution.x, solution.y_0, label='Approximated Solution')\nplt.plot(solution.x, solution.x**2, label='True Solution', linestyle='--')\nplt.xlabel('x') # Label for the x-axis\nplt.ylabel('y') # Label for the y-axis\nplt.grid(True) # Show a grid for better readability\nplt.legend()\nplt.show()"
  },
  {
    "objectID": "content/post/tswift-beads/post.html",
    "href": "content/post/tswift-beads/post.html",
    "title": "Maximising the Number of Friendship Bracelets for the Taylor Swift Concert",
    "section": "",
    "text": "import re \nsong_list = [\n\"Tim McGraw\",\n\"Marys Song\",\n\"Our Song\",\n\"Im Only Me When Im With You\",\n\"Invisible\",\n\"A Perfectly Good Heart\",\n\"Last Christmas\",\n\"Christmases When You Were Mine\",\n\"Santa Baby\",\n\"Silent Night\",\n\"Christmas Must Be Something More\",\n\"White Christmas\",\n\"Jump Then Fall\",\n\"Untouchable\",\n\"Forever  Always\",\n\"Come In With The Rain\",\n\"Superstar\",\n\"The Other Side Of The Door\",\n\"Fearless\",\n\"Fifteen\",\n\"Love Story\",\n\"Hey Stephen\",\n\"White Horse\",\n\"You Belong With Me\",\n\"Breathe\",\n\"Tell Me Why\",\n\"Youre Not Sorry\",\n\"The Way I Loved You\",\n\"Forever and Always\",\n\"The Best Day\",\n\"Change\",\n\"Mine\",\n\"Sparks Fly\",\n\"Back To December\",\n\"Speak Now\",\n\"Dear John\",\n\"Mean\",\n\"The Story Of Us\",\n\"Never Grow Up\",\n\"Enchanted\",\n\"Better Than Revenge\",\n\"Innocent\",\n\"Haunted\",\n\"Last Kiss\",\n\"Long Live\",\n\"Ours\",\n\"If This Was A Movie\",\n\"Superman\",\n\"State Of Grace\",\n\"Red\",\n\"Treacherous\",\n\"I Knew You Were Trouble\",\n\"All Too Well\",\n\"TwentyTwo\",\n\"I Almost Do\",\n\"We Are Never Ever Getting Back Together\",\n\"Come Back Be Here\",\n\"Girl At Home\",\n\"Welcome To New York\",\n\"Blank Space\",\n\"Style\",\n\"Out Of The Woods\",\n\"All You Had To Do Was Stay\",\n\"Shake It Off\",\n\"I Wish You Would\",\n\"Bad Blood\",\n\"Wildest Dreams\",\n\"How You Get The Girl\",\n\"This Love\",\n\"I Know Places\",\n\"Clean\",\n\"Wonderland\",\n\"You Are In Love\",\n\"New Romantics\",\n\"Ready For It\",\n\"End Game\",\n\"I Did Something Bad\",\n\"Dont Blame Me\",\n\"Delicate\",\n\"Look What You Made Me Do\",\n\"So It Goe\",\n\"Gorgeous\",\n\"Getaway Car\",\n\"King Of My Heart\",\n\"Dancing With Our Hands Tied\",\n\"Dress\",\n\"This Is Why We Cant Have Nice Things\",\n\"Call It What You Want\",\n\"New Years Day\",\n\"I Forgot That You Existed\",\n\"Cruel Summer\",\n\"Lover\",\n\"The Man\",\n\"The Archer\",\n\"I Think He Knows\",\n\"Miss Americana & The Heartbreak Prince\",\n\"Paper Rings\",\n\"Cornelia Street\",\n\"Death By A Thousand Cuts\",\n\"London Boy\",\n\"Soon Youll Get Better\",\n\"False God\",\n\"You Need To Calm Down\",\n\"Afterglow\",\n\"ME\",\n\"Its Nice To Have A Friend\",\n\"Daylight\",\n\"the one\",\n\"cardigan\",\n\"the last great american dynasty\",\n\"exile\",\n\"my tears ricochet\",\n\"mirrorball\",\n\"seven\",\n\"august\",\n\"this is me trying\",\n\"illicit affairs\",\n\"invisible string\",\n\"mad woman\",\n\"epiphany\",\n\"betty\",\n\"peace\",\n\"hoax\",\n\"the lakes\",\n\"willow\",\n\"champagne problems\",\n\"gold rush\",\n\"tis the damn season\",\n\"tolerate it\",\n\"no body no crime\",\n\"happiness\",\n\"dorothea\",\n\"coney island\",\n\"ivy\",\n\"cowboy like me\",\n\"long story short\",\n\"marjorie\",\n\"closure\",\n\"evermore\",\n\"right where you left me\",\n\"its time to go\",\n\"You All Over Me\",\n\"Mr Perfectly Fine\",\n\"We Were Happy\",\n\"Thats When\",\n\"Dont You\",\n\"Bye Bye Baby\",\n\"Message In A Bottle\",\n\"I Bet You Think About Me\",\n\"Forever Winter\",\n\"Run\",\n\"The Very First Night\",\n\"All Too Well\",\n\"Lavender Haze\",\n\"Maroon\",\n\"Anti-Hero\",\n\"Snow On The Beach\",\n\"Youre On Your Own Kid\",\n\"Midnight Rain\",\n\"Question\",\n\"Vigilante Shit\",\n\"Bejeweled\",\n\"Labyrinth\",\n\"Karma\",\n\"Sweet Nothing\",\n\"Mastermind\",\n\"Hits Different\",\n\"Bigger Than The Whole Sky\",\n\"Paris\",\n\"High Infidelity\",\n\"Glitch\",\n\"Wouldve Couldve Shouldve\",\n\"Dear Reader\",\n\"Electric Touch\",\n\"When Emma Falls in Love\",\n\"I Can See You\",\n\"Castles Crumbling\",\n\"Foolish One\",\n\"Timeless\",\n\"Slut\",\n\"Say Dont Go\",\n\"Now That We Dont Talk \",\n\"Suburban Legends\",\n\"Is It Over Now\",\n\"Sweeter Than Fiction\",\n\"Red\",\n\"Fearless\",\n\"Midnights\",\n\"Reputation\",\n\"Lover\",\n\"Folklore\",\n\"Evermore\",\n\"Red\"]\n\nbead_dict = {\n    'a': 5,\n    'b': 9,\n    'c': 12,\n    'd': 4,\n    'e': 5,\n    'f': 5,\n    'g': 10,\n    'h': 13,\n    'i': 14,\n    'j': 11,\n    'k': 6,\n    'l': 12,\n    'm': 15,\n    'n': 9,\n    'o':4,\n    'p': 12,\n    'q': 9,\n    'r': 4,\n    's': 10,\n    't': 6,\n    'u': 6,\n    'v': 11,\n    'x': 6,\n    'y': 11,\n    'z': 17 }\nWith Taylor Swift coming to Melbourne next week, my house has started its prep for the concert. An important part of that preparation is making friendship bracelets to trade at the concert. So we headed down to Spotlight and grabbed ourselves a couple of bags of beads to make the bracelets. However, when we opened them up, we found that the distribution of letters was all over the place. We had a heap of useless Zs while also having almost no vowels. Instead of driving back to Spotlight, I decided to see if I could make enough friendship bracelets from the letters we already had, while also being a bit clever about which songs we were going to make friendship bracelets for."
  },
  {
    "objectID": "content/post/tswift-beads/post.html#first-try",
    "href": "content/post/tswift-beads/post.html#first-try",
    "title": "Maximising the Number of Friendship Bracelets for the Taylor Swift Concert",
    "section": "First Try",
    "text": "First Try\nI set out to make an algorithm to determine the best set of song titles we could use. I want to assign each song title a cost, and then make the song with the lowest cost the bracelets. I can keep doing this until I can’t make any more bracelets. To determine the cost of a song title, I just summed the costs of its letters. The cost of the letters was the number of occurrences it had in the list of songs divided by the number of beads I had remaining for that letter.\n\nfrom collections import defaultdict\nimport re\n\ndef count_chars_in_list(list_of_strings):\n    char_counts = defaultdict(int)\n    \n    for string in list_of_strings:\n        for char in string:\n            char_counts[char] += 1\n    \n    return dict(char_counts)\n\n\ndef bracelets(song_list, bead_dict):\n\n    # W and M is interchangeable\n    cleaned_dict = {\n        re.sub(r'\\W+', '', i.lower()).replace(\"w\",\"m\"): i \n        for i in song_list\n    }\n\n    # dict of letter usage totals\n    letter_popularity = count_chars_in_list(cleaned_dict.keys())\n\n    # will run until a break is called\n    while True:\n        cost_dict = {}\n        # Determine the cost of all the songs\n        for song in cleaned_dict.keys():\n            song_cost = 0\n            flag = False\n            for char in song: \n                # Assign the cost by adding up beads value\n                if char in bead_dict:\n                    # If no beads for that letter are left then that word cant be formed\n                    if bead_dict[char] == 0:\n                        flag = True\n                        break\n                    else:\n                        song_cost += letter_popularity[char]/bead_dict[char]\n            if not flag:\n                cost_dict[song] = song_cost\n\n        # Finish loop if no more songs can be made\n        if len(cost_dict) ==0:\n            break\n        # Find the cheapest song\n        cost_dict_sorted = list(dict(sorted(cost_dict.items(), key=lambda item: item[1])).keys())\n        cheapeast_song = cost_dict_sorted[0]\n        print(cleaned_dict[cheapeast_song])\n        # Remove the cheapest songs beads from the bead counts\n        for char in cheapeast_song:\n            bead_dict[char] -= 1\nbracelets(song_list.copy(), bead_dict.copy())\n\nivy\nivy\nivy\nivy\nivy\nivy\nivy\nivy\nivy\nRun\nSlut\nME\nSlut\nivy\nME\nRun\nhoax\nSlut\nME\nhoax\nGlitch\nRun\nivy\nME\nhoax\nGlitch\nhoax\nME\nGlitch\nKarma\n\n\nThis was pretty good, but let’s remove the repeated songs because I don’t want to have 10 bracelets with Ivy on them. We can do this by adding del cleaned_dict[cheapest_song] to the end of the loop.\n\ndef bracelets(song_list, bead_dict):\n    cleaned_dict = {re.sub(r'\\W+', '', i.lower()).replace(\"w\",\"m\"): i for i in song_list}\n    letter_popularity = count_chars_in_list(cleaned_dict.keys())\n\n    while True:\n        cost_dict = {}\n        for song in cleaned_dict.keys():\n            song_cost = 0\n            flag = False\n            for char in song: \n                # Assign the cost by adding up beads value\n                if char in bead_dict:\n                    if bead_dict[char] == 0:\n                        flag = True\n                        break\n                    else:\n                        song_cost += letter_popularity[char]/bead_dict[char]\n            if not flag:\n                cost_dict[song] = song_cost\n        if len(cost_dict) ==0:\n            break\n        cost_dict_sorted = list(dict(sorted(cost_dict.items(), key=lambda item: item[1])).keys())\n        cheapeast_song = cost_dict_sorted[0]\n        print(cleaned_dict[cheapeast_song])\n        for char in cheapeast_song:\n            bead_dict[char] -= 1\n        del cleaned_dict[cheapeast_song]\n\n\nbracelets(song_list.copy(), bead_dict.copy())\n\nivy\nRun\nSlut\nME\nGlitch\nhoax\nMine\nwillow\nParis\naugust\nMidnights\nRed\nMean\nOurs\nDaylight\nInvisible\nLondon Boy"
  },
  {
    "objectID": "content/post/tswift-beads/post.html#getting-picky",
    "href": "content/post/tswift-beads/post.html#getting-picky",
    "title": "Maximising the Number of Friendship Bracelets for the Taylor Swift Concert",
    "section": "Getting Picky",
    "text": "Getting Picky\nI presented this list to my housemates only to get the response, ‘I hate ME!’ So, I did some cleaning to remove some of the so-called ‘banned songs’. It also turns out that I’m not allowed to listen to “London Boy” anymore since the guy it is about is canceled or something? Not sure, but now we have a new list that doesn’t include the songs we don’t want.\n\nbannded_songs = [\n\"Invisible\",\n\"London Boy\",\n\"ME\",\n'hoax',\n'run'\n]\n\nbracelets([song for song in song_list if song not in bannded_songs], bead_dict.copy())\n\nivy\nRun\nSlut\nGlitch\nwillow\nMine\nParis\naugust\nMean\nOurs\nMidnights\nClean\nStyle\ngold rush\nDaylight\nLong Live"
  },
  {
    "objectID": "content/post/tswift-beads/post.html#a-final-go",
    "href": "content/post/tswift-beads/post.html#a-final-go",
    "title": "Maximising the Number of Friendship Bracelets for the Taylor Swift Concert",
    "section": "A Final Go",
    "text": "A Final Go\nI tried showing this list, which received a better reception, but there were still a couple of non-negotiable songs that needed to be included. We also decided that the Qs and the Os look close enough to be interchangeable, so I changed the way we generate the cleaned dict to reflect that.\n\ndef bracelets(song_list, bead_dict):\n    cleaned_dict = {re.sub(r'\\W+', '', i.lower()).replace(\"w\",\"m\").replace(\"q\",'o'): i for i in song_list}\n    letter_popularity = count_chars_in_list(cleaned_dict.keys())\n\n    while True:\n        cost_dict = {}\n        for song in cleaned_dict.keys():\n            song_cost = 0\n            flag = False\n            for char in song: \n                # Assign the cost by adding up beads value\n                if char in bead_dict:\n                    if bead_dict[char] == 0:\n                        flag = True\n                        break\n                    else:\n                        song_cost += letter_popularity[char]/bead_dict[char]\n            if not flag:\n                cost_dict[song] = song_cost\n        if len(cost_dict) ==0:\n            break\n        cost_dict_sorted = list(dict(sorted(cost_dict.items(), key=lambda item: item[1])).keys())\n        cheapeast_song = cost_dict_sorted[0]\n        print(cleaned_dict[cheapeast_song])\n        for char in cheapeast_song:\n            bead_dict[char] -= 1\n        del cleaned_dict[cheapeast_song]\n\n\n# Move all the Q beads to O\nbead_dict['o'] += bead_dict['q']\ndel bead_dict['q']\n\nrequired_songs = ['Delicate', 'Lover']\n    \nfor song in required_songs:\n    print(song)\n    for char in re.sub(r'\\W+', '', song.lower()).replace(\"w\",\"m\").replace(\"q\",'o'):\n        bead_dict[char] -= 1\n\nbracelets([song for song in song_list if song not in bannded_songs and song not in required_songs], bead_dict.copy())\n\nDelicate\nLover\nivy\nwillow\nRun\nSlut\nGlitch\nOurs\nBad Blood\naugust\nMine\nParis\nMidnights\nLong Live\nLast Kiss\n\n\nAnd there’s a final list of 14 bracelets we can make with our current beads. Would it have been faster to drive back to Spotlight to buy more beads? Probably, but this was more fun."
  },
  {
    "objectID": "content/post/taylor-series/post-2.html",
    "href": "content/post/taylor-series/post-2.html",
    "title": "Making a Python Library to solve differential Equations",
    "section": "",
    "text": "After having the initial idea I wrote up in a previous post, I thought it was a good idea to turn it into a python library so that I can use it as part of my other projects.\nIt also gives me a chance to see numerically how well the new method works compared to the Euler method.\n\nFirst Steps\nSo in the last post I set out the method such that: \\[ \\begin{bmatrix}\ny(x+h)\\\\\ny'(x+h)\\\\\ny''(x+h)\\\\\n...\\\\\ny^{n}(x+h)\\\\\n\\end{bmatrix} =  S \\cdot \\begin{bmatrix}\ny(x)\\\\\ny'(x)\\\\\ny''(x)\\\\\n...\\\\\ny^{n}(x)\\\\\n\\end{bmatrix} + \\epsilon \\]\nIn the Euler method, \\(S\\) is: \\[\\begin{bmatrix}\n1 & h & 0 &  ... & 0\\\\\n0 & 1 & h &  ... & 0\\\\\n0 & 0 & 1 &  ... & 0\\\\\n... & ... & ... &  ... & ...\\\\\n0 & 0 & 0 &  ... & 1\\\\\n\\end{bmatrix}\\]\nAnd in the new method I proposed, \\(S\\) is now: \\[ \\begin{bmatrix}\n1 & \\frac{h}{1!} & \\frac{h^2}{2!} &  ... & \\frac{h^n}{n!}\\\\\n0 & 1 & \\frac{h}{1!} &  ... & \\frac{h^{n-1}}{(n-1)!}\\\\\n0 & 0 & 1 &  ... & \\frac{h^{n-2}}{(n-2)!}\\\\\n... & ... & ... &  ... & ...\\\\\n0 & 0 & 0 &  ... & 1\\\\\n\\end{bmatrix}\\]\nConverting these matrices into python is fairly easy.\n\nimport numpy as np\nimport math\n\n\ndef euler(dims, h):\n    # Start with an identity matrix\n    step_matrix = np.identity(dims)\n    # Add in all the h values\n    for i in range(dims - 1):\n        step_matrix[i, i + 1] = h\n    return step_matrix\n\n\ndef expanded_euler(dims, h):\n    step_matrix = np.zeros((dims, dims))\n    for i in range(dims):\n        for j in range(i, dims):\n            # Is 1, and h at j-i =0, 1 respectively\n            step_matrix[i, j] = h ** (j - i) / math.factorial(j - i)\n    return step_matrix\n\n\n\nMaking a step simulation\nNow that we have the stepping matrices, we can use them to iterate from an initial value. All we have to do is generate the stepping matrix for the given problem, and then for each step, we just multiple the previous step by the stepping matrix.\n\ndef IVP(x, y, step_matrix_generator, steps=10, h=0.1):\n    dims = len(y)\n    step_matrix = step_matrix_generator(dims, h)\n    output_dict = {x: y}\n\n    x_n = x\n    y_n = y.copy()\n    i = 0\n    while i &lt; steps:\n        y_n = step_matrix @ y_n\n        x_n += h\n        output_dict[x_n] = y_n\n        i += 1\n\n    return output_dict\n\n\n\nTesting and Comparing the methods\nNow we can run the simulations, let’s see how good they are. Say you throw a ball up in the air and track its vertical position. The path of the ball is described by the equation \\(y'' = -9.8\\). We can know for a fact that the solution to this equation is \\(\\frac{-9.8}{2}x^2+V_0x+P_0\\), where \\(V_0\\) is the initial velocity and \\(P_0\\) is the initial position. So now lets compare the real solutions to the simulations.\n\n# Time starts at 0\nx = 0\n# Start the object moving upwards with a velocity of 10\ny = np.array([0, 10, -9.8])\n\neuler_result = IVP(x, y, euler)\nexpanded_euler_result =IVP(x, y, expanded_euler)\ntrue_result = {x: np.array([\n                    -4.9 * x**2 + 10 * x,\n                    -9.8 * x + 10,\n                    -9.8\n                ]) for x in np.arange(0, 1.1, 0.1)}\n\n\nimport numpy as np\nimport pandas as pd\nimport mplcatppuccin\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\n\nmpl.style.use(\"macchiato\")\n\n# Extracting data for plotting\neuler_xs = list(euler_result.keys())\neuler_ys = [position[0] for position in euler_result.values()]\n\nexpanded_euler_xs = list(expanded_euler_result.keys())\nexpanded_euler_ys = [position[0] for position in expanded_euler_result.values()]\n\ntrue_xs = list(true_result.keys())\ntrue_ys = [position[0] for position in true_result.values()]\n\n# Plotting the results\nplt.plot(euler_xs, euler_ys, label='Euler Method')\nplt.plot(expanded_euler_xs, expanded_euler_ys, label='Expanded Euler Method')\nplt.plot(true_xs, true_ys, label='True Solution', linestyle=':')\n\nplt.title('Projectile Motion under Gravity')\nplt.xlabel('Time (seconds)')\nplt.ylabel('Height (meters)')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n/tmp/ipykernel_10695/1645241578.py:3: DeprecationWarning: The catppuccin-matplotlib package is deprecated, please upgrade to https://github.com/catppuccin/python (pip install catppuccin)\n\n\n  import mplcatppuccin\n\n\n\n\n\n\n\n\n\nSo from here, we’re looking pretty good. The new method is much closer to the true solution than the Euler method in in this scenario. However, when working with numerical methods, it generally isn’t too hard to improve the accuracy of the model, but there will be a trade off in computation time. So lets see how much longer it takes to compute the approximation with the expanded method comparing it to the original.\n\nimport timeit\n\n# Define the step counts to test\nsteps_list = [10, 100, 1000, 10000, 100000]\n\n# Lists to store execution times for each method\neuler_times = []\nexpanded_euler_times = []\n\n# Testing the functions with the different step counts and store the execution times\nfor steps in steps_list:\n    euler_time = timeit.timeit(lambda: IVP(x, y, euler, steps), number=1)\n    expanded_euler_time = timeit.timeit(lambda: IVP(x, y, expanded_euler, steps), number=1)\n    \n    euler_times.append(euler_time)\n    expanded_euler_times.append(expanded_euler_time)\n\n\n# Now we plot the results\nplt.figure(figsize=(10, 5))\n\n# Plot Euler times\nplt.plot(steps_list, euler_times, label='Euler Method', marker='o')\n\n# Plot Expanded Euler times\nplt.plot(steps_list, expanded_euler_times, label='Expanded Euler Method', marker='s')\n\n# Adding labels and title\nplt.xlabel('Number of Steps')\nplt.ylabel('Execution Time (seconds)')\nplt.title('Execution Time for Euler Methods with Different Steps')\nplt.xscale('log')  # Since we have a wide range of steps, a log scale might be more informative\nplt.yscale('log')  # Using a log scale for time to better see differences for small times\nplt.legend()\n\n# Show the plot\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nLooking at this graph, we can see that we’re not sacrificing compute time for better accuracy, so this seems like a big win, though I haven’t optimised the Euler method that much. But overall, the new method seems to show some promise in approximating differential equations."
  },
  {
    "objectID": "content/about.html",
    "href": "content/about.html",
    "title": "About",
    "section": "",
    "text": "Hiya, I’m Alfie a techie working in Melbourne, Australia. I often find myself writing up little projects in my spare time so I may as well put them out there."
  }
]