{"title":"Predicting the 2023 Hottest 100","markdown":{"yaml":{"title":"Predicting the 2023 Hottest 100","author":"Alfie Chadwick","date":"2024-01-26","lastmod":"`r Sys.Date()`","tags":["Music","Visualizations","ML"]},"headingText":"Read in the results data to dataframes and add a year column","containsRefs":false,"markdown":"\n\n\n```{r setup,  include=FALSE}\nlibrary(tidyverse)\nlibrary(catppuccin)\nlibrary(jsonlite)\nlibrary(patchwork)\nlibrary(lubridate)\n\nknitr::opts_chunk$set( echo = FALSE, warning = FALSE, message = FALSE, cache = TRUE)\n\n\ntheme_dark_catppuccino <- function(base_size = 11, base_family = \"\") {\n  theme_minimal(base_size = base_size, base_family = base_family) +\n    theme(\n      # Define colors\n      text = element_text(color = \"#cad3f5\"),\n      \n      # Background colors\n      plot.background = element_rect(fill = \"#24273a\", color = NA),\n      panel.background = element_rect(fill = \"#1e2030\", color = NA),\n      plot.margin = margin(2, 2, 2, 2, \"pt\"),\n\n      # Grid colors\n      panel.grid.major = element_line(color = \"#494d64\", size = 0.25),\n      panel.grid.minor = element_line(color = \"#494d64\", size = 0.25),\n      \n      # Axis colors and ticks\n      axis.ticks = element_line(color = \"#cad3f5\"),\n      axis.text = element_text(color = \"#cad3f5\"),\n      axis.title = element_text(color = \"#cad3f5\"),\n      axis.line = element_line(color = \"#cad3f5\"),\n      \n      # Legend colors\n      legend.background = element_rect(fill = \"#363a4f\"),\n      legend.text = element_text(color = \"#cad3f5\"),\n      legend.title = element_text(color = \"#cad3f5\", face = \"bold\"),\n      legend.position = \"none\",\n\n      # Title and subtitle\n      plot.title = element_text(color = \"#b7bdf8\", size = base_size * 1.2, \n                                hjust = 0.5, face = \"bold\"),\n      plot.subtitle = element_text(color = \"#b7bdf8\", size = base_size * 0.9,\n                                   hjust = 0.5),\n                                   \n      # Caption\n      plot.caption = element_text(color = \"#f4dbd6\", hjust = 0.5, \n                                  size = base_size * 0.8)\n    )\n}\n\ntheme_set(theme_dark_catppuccino())\n\n```\n\n```{r dataset }\n\nresults_files <- c('2016_results.csv', '2017_results.csv', '2018_results.csv', '2019_results.csv', '2020_results.csv', '2021_results.csv', '2022_results.csv')\nplays_files <- c('2016_filtered.json', '2017_filtered.json', '2018_filtered.json', '2019_filtered.json', '2020_filtered.json', '2021_filtered.json', '2022_filtered.json', '2023_filtered.json')\n\nresults <- lapply(results_files, function(file) {\n  data <- read.csv(paste('data/', file, sep=''))\n  # Extract the year from the file name and add it as a column\n  year <- as.numeric(sub(\"_results.csv\", \"\", file))\n  data$Year <- year\n  return(data)\n})\n\n# Read in the plays data to dataframes and add a year column\nplays <- lapply(plays_files, function(file) {\n  data <- fromJSON(paste('data/', file, sep=''))\n  # Extract the year from the file name and add it as a column\n  year <- as.numeric(sub(\"_filtered.json\", \"\", file))\n  data$Year <- year\n  return(data)\n})\n\n# Assuming you want to combine all dataframes of each type (results, plays) into one dataframe\n# Combine all the results into one dataframe\ncombined_results <- do.call(rbind, results)\n\n# Combine all the plays into one dataframe\ncombined_plays <- do.call(rbind, plays)\n\n\ncharts <-  read_csv('https://raw.githubusercontent.com/caseybriggs/ARIA-charts/main/single_charts.csv')\n\n\nclean_artist_name <- function(artist_string) {\n  # Convert the string to lowercase\n  artist_string <- tolower(artist_string)\n  \n  # remove any text within parentheses or \n  artist_string <- gsub(\"\\\\(.+?\\\\)\", \"\", artist_string)\n  # Remove content in square brackets\n  artist_string <- gsub(\"\\\\[.+?\\\\]\", \"\", artist_string)\n  \nmain_artist <- unlist(strsplit(artist_string, \" feat | featuring | ft | with | x | and | & | vs |, \"))[1]\n\n    main_artist <- iconv(main_artist, from = \"UTF-8\", to = \"ASCII//TRANSLIT\")\n    main_artist <- gsub(\"[[:punct:]]\", \"\", main_artist)\n  \n  # trim leading and trailing whitespace\n  main_artist <- trimws(main_artist)\n  \n  return(main_artist)\n}\n\nclean_song_name <- function(song_string) {\n  # Convert the string to lowercase\n  song_string <- tolower(song_string)\n  \n  # remove any text within parentheses or \n  song_string <- gsub(\"\\\\(.+?\\\\)\", \"\", song_string)\n  # Remove content in square brackets\n  song_string <- gsub(\"\\\\[.+?\\\\]\", \"\", song_string)\n  \n  songname <- unlist(strsplit(song_string, \" feat | featuring | ft | with \"))[1]\n  \n  # trim leading and trailing whitespace\n  songname <- trimws(songname)\n  \n  return(songname)\n}\n\n\ncombined_results <- combined_results %>%\n  mutate(\n    Song = map_chr(Song, clean_song_name),\n    Artist = map_chr(Artist, clean_artist_name)\n  )\n\ncleaned_pairs <- combined_plays %>%\n  distinct(title, artist)  %>%\n  mutate(\n    Song = map_chr(title, clean_song_name),\n    Artist = map_chr(artist, clean_artist_name)\n  )\n\ncombined_plays <- combined_plays %>%\n  left_join(cleaned_pairs, by = c(\"title\", \"artist\")) %>%\n  select(-title, -artist, Song, Artist, everything()) %>%\n  filter(Year > 2015, Year < 2024) %>%\n  select(-title, -artist)\n\ncharts <- charts %>%\n  mutate(\n    Song = map_chr(title, clean_song_name),\n    Artist = map_chr(artist, clean_artist_name),\n    Year = year(ymd(chart_date)),\n    chart_rank = rank,\n    Week = week(ymd(chart_date))\n  ) %>% \n  filter(Year > 2015, Year < 2024) %>%\n  select(-title, -artist)\n\n\nchart_results <- combined_results %>%\n  left_join(charts, by = c(\"Song\" = \"Song\", \"Artist\" = \"Artist\", \"Year\" = \"Year\"))\n\ncombined_data <- combined_results %>%\n  inner_join(combined_plays, by = c(\"Song\" = \"Song\", \"Artist\" = \"Artist\", \"Year\" = \"Year\")) %>%\n  filter(Year == year(ymd_hms(timestamp)))\n\ncombined_data_full <- combined_results %>%\n  right_join(combined_plays, by = c(\"Song\" = \"Song\", \"Artist\" = \"Artist\", \"Year\" = \"Year\")) %>%\n  filter(Year == year(ymd_hms(timestamp)))\n \n\n```\n\nLike many Australians, I spent my last Saturday in January getting hyped for the Triple J Hottest 100 countdown. And for the past few years, there has been a project run by [100 Warm Tunas](https://100warmtunas.com/) that has been remarkably accurate at predicting the results of the countdown.\n\nWarm Tunas makes predictions by scraping social media posts for people's votes and then collating them as a sample of all votes. While this method is highly effective, I feel that it misses the point a bit when it comes to understanding why a song is popular.\n\nTherefore, this year, I have set out to determine the top songs in the 2023 countdown without relying on anything related to the voting itself.\n\n## My Hypotheses\n\nHeading into this, I have a few ideas as to factors that will make a song perform well in the countdown:\n\n\n### Plays on Triple J\n\nI feel this factor is pretty self-explanatory. If a song is being played a lot on Triple J, it's most likely popular with the listener base and will get more votes in the Hottest 100.\n\n### Chart Success\n\nThis one is a bit weirder, as I don't think that just getting to number one in the ARIA charts will make you a top pick for Triple J listeners. Otherwise, the countdown would be topped by the year's biggest pop hits. If a song is too popular in the mainstream, it seems to fall out of favor with Triple J listeners. However, there are some notable exceptions to this, such as \"Bad Guy\" by Billie Eilish and \"Thrift Shop\" by Macklemore, which both took out the top spot in their respective years.\n\n### Time of Release and Peak\n\nThis idea is commonly thrown around when talking about the Oscars, so I feel that it's probably going to be applicable to the Hottest 100 as well. Being at peak popularity when people are voting is probably going to be useful. Similarly, a song that hung around for a long time will probably be voted for more than a song that only hung around for a week.\n\n# Play Data\n\nI gathered the data for all plays on Triple J for the last 8 years from their [API](https://music.abcradio.net.au/api/v1/plays/search.json?limit=100&offset=0&page=0&station=triplej), which left me with a dataset that looks like this:\n\n\n```{R dataset-plot}\n\np1 <- combined_plays %>%\n  filter(release_year >= 2016, release_year <= 2023) %>%\n  ggplot( ) +\n  geom_bar(aes(x=factor(Year), fill=factor(Year)), show.legend = FALSE ) +\n  scale_fill_catppuccin(palette=\"macchiato\",  reverse = FALSE)+\n  labs(x=\"Year\", y=\"Number of Played Songs\") +\n  ggtitle('Total Plays By Year')\n\n\np2 <- combined_plays %>%\n\n  distinct(release_year, Song, Artist) %>%\n  count(release_year, name = \"num_unique_pairs\") %>%\n  filter(release_year >= 2016, release_year <= 2023) %>%\n  ggplot(aes(x = release_year, y = num_unique_pairs, fill = factor(release_year))) +\n  geom_bar(stat = \"identity\") +\n  labs(title = \"Number of Songs Eligible Each Year\",\n       x = \"Release Year\",\n       y = \"Number of Songs\") +\n  scale_fill_catppuccin(palette=\"macchiato\",  reverse = FALSE)\n\n\np1 / p2\n\n```\n\n## Number of Plays\n\nTo me, the most obvious indicator of a song's popularity is the number of plays it receives. So, we can start by examining that.\n\n```{r plays}\n\n\np1 <-combined_plays %>%\n  filter(release_year >= 2016 & release_year <= 2023) %>%\n  filter(release_year == Year) %>%\n  group_by(release_year, Song, Artist) %>%\n  summarize(\n    first_timestamp = ymd_hms(min(timestamp)),\n    total_plays = n(),\n    .groups = \"drop\"\n  ) %>%\n  ggplot(aes(x = first_timestamp, y = total_plays, color = factor(release_year))) +\n  geom_point() +\n  scale_color_catppuccin(palette = \"macchiato\") +\n  labs(x = \"Date of First Play\", y = \"Total Number of Plays\", title = \"Total Number of Plays In Release Year\", color = 'Release Year') +\n  scale_y_continuous(limit = c(0, NA))\n\np2 <- combined_plays %>%\n  filter(release_year >= 2016 & release_year <= 2023) %>%\n  filter(release_year == year(ymd_hms(timestamp))) %>%\n  count(Song) %>%\n  group_by(n) %>%\n  summarize(number_of_songs = n(), .groups = \"drop\")  %>%\n  filter(number_of_songs > 1) %>%\n    ggplot(aes(x = n, y = number_of_songs)) +\n      geom_line(color = \"#cad3f5\") + # Changed to line chart\n      geom_point(color = '#bb9af7') + # You can keep points to show exact data spots\n      labs(x = \"Total Number of Plays\", y = \"Number of Songs\", title = \"Line Chart of Songs vs Total Plays by Release Year\") +\n      scale_y_log10()\n\np1 / p2 \n```\n\nThese plots give us a good insight into the trends in how Triple J selects songs. We have a lot of songs with almost no plays, which are mostly songs that are being presented to the audience to gauge their reaction. If they become popular, the songs will be played frequently, indicated by the absence of songs with 40-60 plays. However, very few songs receive excessive playtime, with only a handful surpassing 200 plays.\n\nWe can also observe the impact of being released early in the year, as these songs have more opportunities to be played throughout the year, resulting in a downward slope for each year.\n\n\n## How Total Plays Impact Success\n```{R plays-vs-success}\n\n combined_data %>%\n group_by(Song, Artist, rank, Year) %>%\n  summarise(number_of_plays = n(), .groups=\"drop\") %>%\n  filter(number_of_plays > 1) %>%\nggplot( aes(y = rank, x = number_of_plays, color = factor(Year)))+\n  geom_point()+\n  scale_color_catppuccin(palette = \"macchiato\") +\n  geom_smooth(color = \"#cad3f5\")+\n  theme(legend.position = 'right') +\n  labs(title = 'Position vs Plays', y = 'Final Position', x = \"Number of Plays\", color = 'Year')\n```\n\n\nLooking at the rankings, we can see that the total number of plays doesn't have a massive impact on performance. A song can have five plays or a hundred, and it seems to have a similar outcome in the rankings.\n\nThere is a slight downward trend for songs getting over 120 plays, as these are the absolute most played songs for the year. However, this status still doesn't guarantee a top spot.\n\n## Accounting for Time\n\nA thought I had while looking at the absolute play data is that it disproportionately rewards songs that were released earlier in the year. \n\nTo address this, I have compiled some statistics that consider the peak of the songs, which should eliminate any advantage for being released at the beginning of the year.\n\n```{R plays-vs-success-accounting-for-time}\n\np1 <- combined_data %>%\n  group_by(Song, Artist, rank, Year, week(ymd_hms(timestamp))) %>%\n  summarise(number_of_plays_per_week = n(), .groups=\"drop\") %>%\n  filter(number_of_plays_per_week > 7) %>%\n  group_by(Song, Artist, rank, Year) %>% \n  summarise(peak = n(), .groups=\"drop\") %>%\nggplot( aes(y = rank, x = peak, color = factor(Year)))+\n  geom_point()+\n  scale_color_catppuccin(palette = \"macchiato\") +\n  geom_smooth(color = \"#cad3f5\")+\n  theme(legend.position = 'bottom') +\n  labs(title = \"Weeks > 7 Plays\", y = 'Final Position', x = \"Number of Weeks\", color = 'Year')\n\np2 <- combined_data %>%\n  group_by(Song, Artist, rank, Year, week(ymd_hms(timestamp))) %>%\n  summarise(number_of_plays_per_week = n(), .groups=\"drop\") %>%\n  filter(number_of_plays_per_week > 1) %>% # Removing Join Error\n  group_by(Song, Artist, rank, Year) %>%\n  summarise(peak = max(number_of_plays_per_week), .groups=\"drop\") %>%\nggplot( aes(y = rank, x = peak, color = factor(Year)))+\n  geom_point()+\n  scale_color_catppuccin(palette = \"macchiato\") +\n  geom_smooth(color = \"#cad3f5\")+\n  theme(legend.position = 'bottom') +\n  labs(title = 'Peak Plays Per Week', x = \"Number of Plays\", color = 'Year', y = \"\")\n  \np3 <- combined_data %>%\n  group_by(Song, Artist, rank, Year, week(ymd_hms(timestamp))) %>%\n  summarise(number_of_plays_per_week = n(), .groups=\"drop\") %>%\n  filter(number_of_plays_per_week > 1) %>% # Removing Join Error\n  group_by(Song, Artist, rank, Year) %>%\n  summarise(peak = mean(number_of_plays_per_week), .groups=\"drop\") %>%\nggplot( aes(y = rank, x = peak, color = factor(Year)))+\n  geom_point()+\n  scale_color_catppuccin(palette = \"macchiato\") +\n  geom_smooth(color = \"#cad3f5\")+\n  theme(legend.position = 'bottom') +\n  labs(title = 'Plays Per Week \\n Post Release',  x = \"Number of Plays\", color = 'Year', y = \"\")\n\n\np1\np2\np3\n```\n\nAgain, we can see that there is some useful information, with the peak plays per week showing that songs which have a big peak generally perform well in the final rankings. However, as with the absolute count of plays, there doesn't seem to be a hard and fast rule.\n\n\n# Chart Success\n\nThe ARIA charts collate music sales and streaming data within Australia and produce a weekly list of the top 50 most popular songs. A GitHub user has been kind enough to [compile all of these lists](https://raw.githubusercontent.com/caseybriggs/ARIA-charts/main/single_charts.csv), so we can simply load them and compare the chart results to a song's position in the Hottest 100.\n\n```{R Chart }\n\n# Peak Chart\nchart_summary <- chart_results %>%\n    filter(!is.na(chart_rank)) %>%\n    group_by(Song, Artist, Year, rank.x) %>%\n    summarise(weeks_in_charts = n(),\n    peak_in_carts = min(chart_rank),\n    chart_score = sum(51-chart_rank),\n    .groups=\"drop\") \n\np1 <- chart_summary %>%\nggplot( aes(y = rank.x, x = weeks_in_charts, color = factor(Year)))+\n  geom_point()+\n  scale_color_catppuccin(palette = \"macchiato\") +\n  geom_smooth(color = \"#cad3f5\")+\n  theme(legend.position = 'bottom') +\n  labs(title = 'Weeks In Charts', x = \"Weeks\", color = 'Year', y = \"Hottest 100 Rank\")+\n  scale_y_continuous(limit = c(0, 100)) \n\np2 <- chart_summary %>%\nggplot( aes(y = rank.x, x = peak_in_carts, color = factor(Year)))+\n  geom_point()+\n  scale_color_catppuccin(palette = \"macchiato\") +\n  geom_smooth(color = \"#cad3f5\")+\n  theme(legend.position = 'bottom') +\n  labs(title = 'Peak', x = \"Peak Position\", color = 'Year', y = \"\")+\n  scale_y_continuous(limit = c(0, 100)) \n\np3 <- chart_summary %>%\nggplot( aes(y = rank.x, x = chart_score, color = factor(Year)))+\n  geom_point()+\n  scale_color_catppuccin(palette = \"macchiato\") +\n  geom_smooth(color = \"#cad3f5\")+\n  theme(legend.position = 'bottom') +\n  labs(title = 'Intergral of Chart', x = \"Score\", color = 'Year', y = \"\")+\n  scale_y_continuous(limit = c(0, 100)) \n\np1\np2\np3\n```\n\nThe first thing to note is that these plots are much sparser than the rest. This is because many songs played on Triple J don't make it into the top 50 at all, even though they make it into the Hottest 100.\n\nFor the songs that did make it into the ARIA charts and hung around, they consistently performed well in the countdown. Examples include \"Bad Guy\" by Billie Eilish and \"Dance Monkey\" by Tones and I, which claimed the 1st and 4th spots in their respective years.\n\nHowever, the predictive power of this statistic is again quite limited. Many songs that performed well in the Hottest 100 had poor chart success. For instance, \"Redbone\" by Childish Gambino took the 5th spot in 2015 despite only spending a single week in the charts at rank 42.\n\n\n\n```{R chart-did-it-make-it}\n\nchart_results %>%\n  mutate(chart_rank_na = !is.na(chart_rank)) %>%\n  ggplot(aes(y = rank.x, x = factor(Year), fill = chart_rank_na)) +\n  geom_boxplot(color = 'white') +\n  labs(x = \"Year\", y = \"Hottest 100 Rank\", fill = \"Did it make the Aria Charts\", title = \"Comparing distribution of songs that made the charts vs thoes that didn't\") +\n  theme(legend.position = 'bottom')\n\n```\n\nFrom this chart, we can see that songs that make the charts are outperforming songs that don't. But more importantly, it shows us that making the charts is not a deal-breaker on whether or not a song will perform well in the Hottest 100.\n\n# Timing\n\nAnother thing I wanted to look at was when and how the songs peaked in the play data. Maybe being the popular song would help the song perform around the time that voting is open, which may help with its performance in the final rankings.\n\n```{R week-of-peak}\n\np1 <- combined_data %>%\n  mutate(Week = week(ymd_hms(timestamp)), Year = year(ymd_hms(timestamp))) %>%\n  group_by(Song, Artist, Rank=rank, Year, Week) %>%\n  summarise(plays = n(), .groups = \"drop\") %>%\n  group_by(Song, Artist, Rank, Year) %>%\n  slice_max(order_by = plays, n = 1) %>%\n  ungroup() %>%\nggplot( aes(x = Week, y = Rank) ) +\n  geom_point(aes(color = factor(Year)))+\n  geom_smooth(color = \"#cad3f5\")+\n  scale_color_catppuccin(palette = \"macchiato\", discrete) +\n  labs(title = 'Week of Peak', x = 'Week', y = \"Rank\", color = 'Year')\n\np2 <- combined_data %>%\n  mutate(Week = week(ymd_hms(timestamp)), Year = year(ymd_hms(timestamp))) %>%\n  group_by(Song, Artist, Rank=rank, Year) %>%\n  slice_min(order_by = timestamp, n = 1) %>%\n  ungroup()  %>%\nggplot( aes(x = Week, y = Rank) ) +\n  geom_point(aes(color = factor(Year)))+\n  geom_smooth(color = \"#cad3f5\")+\n  scale_color_catppuccin(palette = \"macchiato\", discrete) +\n  labs(title = 'Week of first play', x = 'Week', color = 'Year', y = \"\")\n\np1\np2\n```\n\nLooking at the above plots, we can see that the week of release or peak really doesn't matter when looking at the final results.\n\nI went on to see if the shape of the peaks looks different for well-performing songs versus poorly performing songs, and again, nothing seems particularly interesting or different between the two.\n\n```{R multiline}\n\np1 <- combined_data %>%\n  mutate(Week = week(ymd_hms(timestamp))) %>%\n  filter(rank < 4 ) %>%\n  group_by(Song, Artist, rank, Year, Week) %>%\n  summarise(plays = n(), .groups=\"drop\") %>%\nggplot( aes(x = Week, y = plays, color = factor(rank), group = interaction(Song, Artist))) +\n  geom_line()+\n  scale_color_catppuccin(palette = \"macchiato\", discrete) +\n  labs(title = 'Position history for Top 3 Tracks', x = 'Week', y = \"Number of Plays\", color = 'Rank')\n\np2 <- combined_data %>%\n  mutate(Week = week(ymd_hms(timestamp))) %>%\n  filter(rank > 96 ) %>%\n  group_by(Song, Artist, rank, Year, Week) %>%\n  summarise(plays = n(), .groups=\"drop\") %>%\nggplot( aes(x = Week, y = plays, color = factor(rank), group = interaction(Song, Artist))) +\n  geom_line()+\n  scale_color_catppuccin(palette = \"macchiato\", discrete) +\n  labs(title = 'Position history for Bottom 3 Tracks', x = 'Week', color = 'Rank', y = \"\")\n  \np1 + p2\n```\n\n# Where we are going wrong\n\nSo it seems that all of my hypotheses are incorrect, and I believe the reason for this is that there is too much variation among the top 100. This is because these songs are already considered the best of the year from a pool of nearly 4000.\n\n```{R overall}\n\ncombined_data_full %>%\n  group_by(Song, Artist, rank, Year) %>%\n  summarise(\n    number_of_plays = n(),\n    .groups = \"drop\"\n  ) %>%\n  mutate(rank_na = ifelse(is.na(rank), \"No\", \"Yes\")) %>%\n  filter(Year < 2023) %>%\n  ggplot(aes(x = factor(Year), y = number_of_plays, fill = rank_na)) +\n  geom_boxplot(color = 'white') +\n  labs(x = \"Year\", y = \"Number of Plays\", fill = 'Did It Make the Top 100?', title = \"Comparing Plays for Songs That did make the 100 vs Didn't\") +\n  theme(legend.position = 'bottom')\n```\n\nLooking at this plot, we can see right away that a song that made the Hottest 100 got more plays than those that didn't, but also that plenty of songs that didn't make the 100 got a comparable number of plays.\n\n# Screw it XGBoost\n\n```{R xdg}\n\n\n\neligible_songs <- combined_plays %>%\n  distinct(Song,  Artist, Year, release_year) %>%\n  filter(Year == release_year) %>%\n  select(-release_year) \n\nplay_stat_time_gt_7 <- combined_plays %>%\n  group_by(Song, Artist, Year, week = week(ymd_hms(timestamp))) %>%\n  summarise(number_of_plays_per_week = n(), .groups=\"drop\") %>%\n  filter(number_of_plays_per_week > 7) %>%\n  group_by(Song, Artist, Year) %>% \n  summarise(weeks_with_more_than_7 = n(), .groups=\"drop\")\n\n  \nplay_stat_time_peak <- combined_plays %>%\n  group_by(Song, Artist, Year, week = week(ymd_hms(timestamp))) %>%\n  summarise(number_of_plays_per_week = n(), .groups = \"drop\") %>%\n  filter(number_of_plays_per_week > 1) %>%\n  arrange(desc(number_of_plays_per_week)) %>%\n  group_by(Song, Artist, Year) %>%\n  summarise(peak_week_JJJ = first(week), peak_plays_JJJ = first(number_of_plays_per_week), .groups = \"drop\")\n\n\nplay_stat_total <- combined_plays %>%\n  filter(release_year >= 2016 & release_year <= 2023) %>%\n  filter(release_year == Year) %>%\n  group_by(Year, Song, Artist) %>%\n  summarize(\n    first_play = ymd_hms(min(timestamp)),\n    total_plays = n(),\n    .groups = \"drop\"\n  ) \n\nchart_stat <- eligible_songs %>%\n  left_join(charts, by = c(\"Song\" = \"Song\", \"Artist\" = \"Artist\", \"Year\" = \"Year\")) %>%\n  filter(Year >= 2016 & Year <= 2023) %>%\n  group_by(Year, Song, Artist) %>%\n  summarize(\n    weeks_in_charts = sum(!is.na(chart_rank), na.rm = TRUE), # Count weeks in charts, excluding NA values\n    peak_in_charts = min(chart_rank, na.rm = TRUE),           # Find the peak position, excluding NA values\n    chart_score = sum(51-chart_rank, na.rm = TRUE),           # Compute the chart score, excluding NA values\n    .groups = \"drop\"\n  ) %>%\n  mutate(\n    weeks_in_charts = ifelse(is.na(weeks_in_charts), NA, weeks_in_charts),\n    peak_in_charts = ifelse(is.na(peak_in_charts) | peak_in_charts == Inf, NA, peak_in_charts), # Use NA instead of Inf when no charts data\n    chart_score = ifelse(is.na(chart_score), NA, chart_score)\n  )\n\nrank_stat <- eligible_songs %>%\n    left_join(combined_results ) %>%\n    mutate(made_100 = !is.na(rank))\n\ndata <- eligible_songs %>%\n    left_join(play_stat_time_gt_7) %>%\n    left_join(play_stat_time_peak) %>%\n    left_join(play_stat_total) %>%\n    left_join(chart_stat) %>%\n    left_join(rank_stat) %>%\n    select(-Country.of.origin)\n    \n\ntraining_data <- data %>% filter(Year > 2015, Year < 2023)\ninferance <- data %>% filter(Year == 2023) %>% \n    select(-rank, -made_100)\n\n\n# Save training data to disk\nsaveRDS(training_data, \"data/training_data.rds\")\nsaveRDS(inferance, \"data/inferance.rds\")\n\n```\n\nI think the direction to go here is to see if we can use ML to find any trends that aren't showing up in the plots.\n\nTo do this, we are going to use XGBoost to train a model to predict the rank of the song using all the stats I wrote out above. The only thing I changed was taking the first play data and setting it to be the month rather than the day to reduce overfitting. For any song that didn't make it into the 100, I set the rank to be 101, as it could be the 101st most popular song that year.\n\n```{R boost-train, results = FALSE}\n\nlibrary(xgboost)\n\nset.seed(64)\n\ntraining_data <- readRDS(\"data/training_data.rds\")\ninferance <- readRDS(\"data/inferance.rds\")\n\n\ndata_cols <- c(\n  \"weeks_with_more_than_7\",\n  \"peak_week_JJJ\",\n  \"peak_plays_JJJ\",\n  \"first_play\",\n  \"total_plays\",\n  \"weeks_in_charts\",\n  \"peak_in_charts\",\n  \"chart_score\"\n)\n\ntraining_data %>% mutate(first_play = month(first_play))\n\ntraining_data[data_cols] <- lapply(training_data[data_cols], as.numeric)\ntraining_data$rank[!training_data$made_100] <- 101\n\n# Prepare the data for XGBoost\ntrain_x <- as.matrix(training_data[, data_cols])\ntrain_y <- lapply(training_data$rank, as.numeric)\n\n# Convert the training data to xgb.DMatrix format\ndtrain <- xgb.DMatrix(data = train_x, label = train_y)\n\n# Set XGBoost parameters\nparams <- list(\n  booster = \"gbtree\",\n  objective = \"reg:squarederror\",\n  max_depth =  6,\n  num_parallel_tree =  200,\n  subsample = 0.8,\n  num_boost_round = 1,\n  eta = 1\n)\n\nxgb_model <- xgboost(\n  params = params,\n  data = dtrain,\n  nrounds = 15,\n  nthread = 8, # Set the number of threads to be used\n  verbose = 1\n)\n\nimportance_matrix <- xgb.importance(feature_names = data_cols, model = xgb_model)\nimportance_df <- as.data.frame(importance_matrix)\n\np1 <-  ggplot(importance_df, aes(x = reorder(Feature, Gain), y = Gain)) +\n  geom_bar(stat = \"identity\") +\n  coord_flip() + # Flip the axes to make it horizontal\n  ylab(\"Gain\") +\n  xlab(\"\")\np2 <-  ggplot(importance_df, aes(x = reorder(Feature, Cover), y = Cover)) +\n  geom_bar(stat = \"identity\") +\n  coord_flip() + # Flip the axes to make it horizontal\n  ylab(\"Cover\") +\n  xlab(\"\")\n\n(p1 + p2) + plot_annotation(title = \"Feature Importance According to XGBoost\")\n\n# Save the trained model to a file for later use\nxgb.save(xgb_model, \"data/xgb_model.bin\")\n\n```\n\nA nice thing about XGBoost is that it can provide insight into the most important factors it uses to predict the results. From the above plots, we can see that the peak of the song on triple J and its total plays contribute significantly to the predictive power. \n\nInterestingly, the chart scores seem to have little effect. However, this can be justified by considering the fact that many songs that make the top 100 never make the charts.\n\nNow that we have the model, we can evaluate its performance in predicting the Hottest 100 by applying it to the play data from 2022.\n\n```{R rebuild}\n\ntest_data = training_data %>% filter(Year == 2022)\n\ntest_x <- as.matrix(test_data[, data_cols])\ntest_y <- lapply(test_data$made_100, as.numeric)\n\npredictions <- predict(xgb_model, test_x)\n\ntest_data$predicted_rank <- predictions\n```\n\n### 2022 Predicted Countdown\n\n```{R rebuild-2022-pred}\n\ntest_data %>% \n  select(Song, Artist, rank, predicted_rank) %>%\n  mutate(predicted_rank = rank(predicted_rank, ties.method = \"first\")) %>%\n  arrange(predicted_rank) %>%  # Sort by predicted_rank\n  select(Song, Artist, Actual = rank) %>%\n  slice_head(n = 20) %>%       # Take the first 20 rows after sorting\n  knitr::kable()\n```\n\n### 2022 Real Countdown\n\n```{R rebuild-2022-real}\n\ntest_data %>% \n  select(Song, Artist, rank, predicted_rank) %>%\n  mutate(predicted_rank = rank(predicted_rank, ties.method = \"first\")) %>%\n  arrange(rank) %>%  # Sort by predicted_rank\n  select(Song, Artist,Predicted =  predicted_rank) %>%\n  slice_head(n = 20) %>%       # Take the first 20 rows after sorting\n  knitr::kable()\n\n```\n\nFrom this, I reckon the model is doing pretty well, so lets have a look at my final predictions for the hottest 100 of 2023.\n\n# My Final Predictions\n\nThe list below seems pretty reasonable, with Doja Cat taking the top spot and my pick for number one, Rush, sitting in 10th. There seems to be a big lean towards pop and a lack of your classic Triple J-style indie rockers, but that might just be the turnout for this year.\n\n```{R 2023, cache = FALSE}\ninferance[data_cols] <- lapply(inferance[data_cols], as.numeric)\ninf <- as.matrix(inferance[, data_cols])\n\npredictions <- predict(xgb_model, inf)\n\ninferance$predicted_rank <- predictions\n\ninferance %>% \n  select(Song, Artist, predicted_rank) %>%\n  mutate(predicted_rank = rank(predicted_rank, ties.method = \"first\")) %>%\n  arrange(predicted_rank) %>%  # Sort by predicted_rank\n  select(Song, Artist) %>%\n  slice_head(n = 100) %>%       # Take the first 20 rows after sorting\n  knitr::kable()\n\n```\n","srcMarkdownNoYaml":"\n\n\n```{r setup,  include=FALSE}\nlibrary(tidyverse)\nlibrary(catppuccin)\nlibrary(jsonlite)\nlibrary(patchwork)\nlibrary(lubridate)\n\nknitr::opts_chunk$set( echo = FALSE, warning = FALSE, message = FALSE, cache = TRUE)\n\n\ntheme_dark_catppuccino <- function(base_size = 11, base_family = \"\") {\n  theme_minimal(base_size = base_size, base_family = base_family) +\n    theme(\n      # Define colors\n      text = element_text(color = \"#cad3f5\"),\n      \n      # Background colors\n      plot.background = element_rect(fill = \"#24273a\", color = NA),\n      panel.background = element_rect(fill = \"#1e2030\", color = NA),\n      plot.margin = margin(2, 2, 2, 2, \"pt\"),\n\n      # Grid colors\n      panel.grid.major = element_line(color = \"#494d64\", size = 0.25),\n      panel.grid.minor = element_line(color = \"#494d64\", size = 0.25),\n      \n      # Axis colors and ticks\n      axis.ticks = element_line(color = \"#cad3f5\"),\n      axis.text = element_text(color = \"#cad3f5\"),\n      axis.title = element_text(color = \"#cad3f5\"),\n      axis.line = element_line(color = \"#cad3f5\"),\n      \n      # Legend colors\n      legend.background = element_rect(fill = \"#363a4f\"),\n      legend.text = element_text(color = \"#cad3f5\"),\n      legend.title = element_text(color = \"#cad3f5\", face = \"bold\"),\n      legend.position = \"none\",\n\n      # Title and subtitle\n      plot.title = element_text(color = \"#b7bdf8\", size = base_size * 1.2, \n                                hjust = 0.5, face = \"bold\"),\n      plot.subtitle = element_text(color = \"#b7bdf8\", size = base_size * 0.9,\n                                   hjust = 0.5),\n                                   \n      # Caption\n      plot.caption = element_text(color = \"#f4dbd6\", hjust = 0.5, \n                                  size = base_size * 0.8)\n    )\n}\n\ntheme_set(theme_dark_catppuccino())\n\n```\n\n```{r dataset }\n\nresults_files <- c('2016_results.csv', '2017_results.csv', '2018_results.csv', '2019_results.csv', '2020_results.csv', '2021_results.csv', '2022_results.csv')\nplays_files <- c('2016_filtered.json', '2017_filtered.json', '2018_filtered.json', '2019_filtered.json', '2020_filtered.json', '2021_filtered.json', '2022_filtered.json', '2023_filtered.json')\n\n# Read in the results data to dataframes and add a year column\nresults <- lapply(results_files, function(file) {\n  data <- read.csv(paste('data/', file, sep=''))\n  # Extract the year from the file name and add it as a column\n  year <- as.numeric(sub(\"_results.csv\", \"\", file))\n  data$Year <- year\n  return(data)\n})\n\n# Read in the plays data to dataframes and add a year column\nplays <- lapply(plays_files, function(file) {\n  data <- fromJSON(paste('data/', file, sep=''))\n  # Extract the year from the file name and add it as a column\n  year <- as.numeric(sub(\"_filtered.json\", \"\", file))\n  data$Year <- year\n  return(data)\n})\n\n# Assuming you want to combine all dataframes of each type (results, plays) into one dataframe\n# Combine all the results into one dataframe\ncombined_results <- do.call(rbind, results)\n\n# Combine all the plays into one dataframe\ncombined_plays <- do.call(rbind, plays)\n\n\ncharts <-  read_csv('https://raw.githubusercontent.com/caseybriggs/ARIA-charts/main/single_charts.csv')\n\n\nclean_artist_name <- function(artist_string) {\n  # Convert the string to lowercase\n  artist_string <- tolower(artist_string)\n  \n  # remove any text within parentheses or \n  artist_string <- gsub(\"\\\\(.+?\\\\)\", \"\", artist_string)\n  # Remove content in square brackets\n  artist_string <- gsub(\"\\\\[.+?\\\\]\", \"\", artist_string)\n  \nmain_artist <- unlist(strsplit(artist_string, \" feat | featuring | ft | with | x | and | & | vs |, \"))[1]\n\n    main_artist <- iconv(main_artist, from = \"UTF-8\", to = \"ASCII//TRANSLIT\")\n    main_artist <- gsub(\"[[:punct:]]\", \"\", main_artist)\n  \n  # trim leading and trailing whitespace\n  main_artist <- trimws(main_artist)\n  \n  return(main_artist)\n}\n\nclean_song_name <- function(song_string) {\n  # Convert the string to lowercase\n  song_string <- tolower(song_string)\n  \n  # remove any text within parentheses or \n  song_string <- gsub(\"\\\\(.+?\\\\)\", \"\", song_string)\n  # Remove content in square brackets\n  song_string <- gsub(\"\\\\[.+?\\\\]\", \"\", song_string)\n  \n  songname <- unlist(strsplit(song_string, \" feat | featuring | ft | with \"))[1]\n  \n  # trim leading and trailing whitespace\n  songname <- trimws(songname)\n  \n  return(songname)\n}\n\n\ncombined_results <- combined_results %>%\n  mutate(\n    Song = map_chr(Song, clean_song_name),\n    Artist = map_chr(Artist, clean_artist_name)\n  )\n\ncleaned_pairs <- combined_plays %>%\n  distinct(title, artist)  %>%\n  mutate(\n    Song = map_chr(title, clean_song_name),\n    Artist = map_chr(artist, clean_artist_name)\n  )\n\ncombined_plays <- combined_plays %>%\n  left_join(cleaned_pairs, by = c(\"title\", \"artist\")) %>%\n  select(-title, -artist, Song, Artist, everything()) %>%\n  filter(Year > 2015, Year < 2024) %>%\n  select(-title, -artist)\n\ncharts <- charts %>%\n  mutate(\n    Song = map_chr(title, clean_song_name),\n    Artist = map_chr(artist, clean_artist_name),\n    Year = year(ymd(chart_date)),\n    chart_rank = rank,\n    Week = week(ymd(chart_date))\n  ) %>% \n  filter(Year > 2015, Year < 2024) %>%\n  select(-title, -artist)\n\n\nchart_results <- combined_results %>%\n  left_join(charts, by = c(\"Song\" = \"Song\", \"Artist\" = \"Artist\", \"Year\" = \"Year\"))\n\ncombined_data <- combined_results %>%\n  inner_join(combined_plays, by = c(\"Song\" = \"Song\", \"Artist\" = \"Artist\", \"Year\" = \"Year\")) %>%\n  filter(Year == year(ymd_hms(timestamp)))\n\ncombined_data_full <- combined_results %>%\n  right_join(combined_plays, by = c(\"Song\" = \"Song\", \"Artist\" = \"Artist\", \"Year\" = \"Year\")) %>%\n  filter(Year == year(ymd_hms(timestamp)))\n \n\n```\n\nLike many Australians, I spent my last Saturday in January getting hyped for the Triple J Hottest 100 countdown. And for the past few years, there has been a project run by [100 Warm Tunas](https://100warmtunas.com/) that has been remarkably accurate at predicting the results of the countdown.\n\nWarm Tunas makes predictions by scraping social media posts for people's votes and then collating them as a sample of all votes. While this method is highly effective, I feel that it misses the point a bit when it comes to understanding why a song is popular.\n\nTherefore, this year, I have set out to determine the top songs in the 2023 countdown without relying on anything related to the voting itself.\n\n## My Hypotheses\n\nHeading into this, I have a few ideas as to factors that will make a song perform well in the countdown:\n\n\n### Plays on Triple J\n\nI feel this factor is pretty self-explanatory. If a song is being played a lot on Triple J, it's most likely popular with the listener base and will get more votes in the Hottest 100.\n\n### Chart Success\n\nThis one is a bit weirder, as I don't think that just getting to number one in the ARIA charts will make you a top pick for Triple J listeners. Otherwise, the countdown would be topped by the year's biggest pop hits. If a song is too popular in the mainstream, it seems to fall out of favor with Triple J listeners. However, there are some notable exceptions to this, such as \"Bad Guy\" by Billie Eilish and \"Thrift Shop\" by Macklemore, which both took out the top spot in their respective years.\n\n### Time of Release and Peak\n\nThis idea is commonly thrown around when talking about the Oscars, so I feel that it's probably going to be applicable to the Hottest 100 as well. Being at peak popularity when people are voting is probably going to be useful. Similarly, a song that hung around for a long time will probably be voted for more than a song that only hung around for a week.\n\n# Play Data\n\nI gathered the data for all plays on Triple J for the last 8 years from their [API](https://music.abcradio.net.au/api/v1/plays/search.json?limit=100&offset=0&page=0&station=triplej), which left me with a dataset that looks like this:\n\n\n```{R dataset-plot}\n\np1 <- combined_plays %>%\n  filter(release_year >= 2016, release_year <= 2023) %>%\n  ggplot( ) +\n  geom_bar(aes(x=factor(Year), fill=factor(Year)), show.legend = FALSE ) +\n  scale_fill_catppuccin(palette=\"macchiato\",  reverse = FALSE)+\n  labs(x=\"Year\", y=\"Number of Played Songs\") +\n  ggtitle('Total Plays By Year')\n\n\np2 <- combined_plays %>%\n\n  distinct(release_year, Song, Artist) %>%\n  count(release_year, name = \"num_unique_pairs\") %>%\n  filter(release_year >= 2016, release_year <= 2023) %>%\n  ggplot(aes(x = release_year, y = num_unique_pairs, fill = factor(release_year))) +\n  geom_bar(stat = \"identity\") +\n  labs(title = \"Number of Songs Eligible Each Year\",\n       x = \"Release Year\",\n       y = \"Number of Songs\") +\n  scale_fill_catppuccin(palette=\"macchiato\",  reverse = FALSE)\n\n\np1 / p2\n\n```\n\n## Number of Plays\n\nTo me, the most obvious indicator of a song's popularity is the number of plays it receives. So, we can start by examining that.\n\n```{r plays}\n\n\np1 <-combined_plays %>%\n  filter(release_year >= 2016 & release_year <= 2023) %>%\n  filter(release_year == Year) %>%\n  group_by(release_year, Song, Artist) %>%\n  summarize(\n    first_timestamp = ymd_hms(min(timestamp)),\n    total_plays = n(),\n    .groups = \"drop\"\n  ) %>%\n  ggplot(aes(x = first_timestamp, y = total_plays, color = factor(release_year))) +\n  geom_point() +\n  scale_color_catppuccin(palette = \"macchiato\") +\n  labs(x = \"Date of First Play\", y = \"Total Number of Plays\", title = \"Total Number of Plays In Release Year\", color = 'Release Year') +\n  scale_y_continuous(limit = c(0, NA))\n\np2 <- combined_plays %>%\n  filter(release_year >= 2016 & release_year <= 2023) %>%\n  filter(release_year == year(ymd_hms(timestamp))) %>%\n  count(Song) %>%\n  group_by(n) %>%\n  summarize(number_of_songs = n(), .groups = \"drop\")  %>%\n  filter(number_of_songs > 1) %>%\n    ggplot(aes(x = n, y = number_of_songs)) +\n      geom_line(color = \"#cad3f5\") + # Changed to line chart\n      geom_point(color = '#bb9af7') + # You can keep points to show exact data spots\n      labs(x = \"Total Number of Plays\", y = \"Number of Songs\", title = \"Line Chart of Songs vs Total Plays by Release Year\") +\n      scale_y_log10()\n\np1 / p2 \n```\n\nThese plots give us a good insight into the trends in how Triple J selects songs. We have a lot of songs with almost no plays, which are mostly songs that are being presented to the audience to gauge their reaction. If they become popular, the songs will be played frequently, indicated by the absence of songs with 40-60 plays. However, very few songs receive excessive playtime, with only a handful surpassing 200 plays.\n\nWe can also observe the impact of being released early in the year, as these songs have more opportunities to be played throughout the year, resulting in a downward slope for each year.\n\n\n## How Total Plays Impact Success\n```{R plays-vs-success}\n\n combined_data %>%\n group_by(Song, Artist, rank, Year) %>%\n  summarise(number_of_plays = n(), .groups=\"drop\") %>%\n  filter(number_of_plays > 1) %>%\nggplot( aes(y = rank, x = number_of_plays, color = factor(Year)))+\n  geom_point()+\n  scale_color_catppuccin(palette = \"macchiato\") +\n  geom_smooth(color = \"#cad3f5\")+\n  theme(legend.position = 'right') +\n  labs(title = 'Position vs Plays', y = 'Final Position', x = \"Number of Plays\", color = 'Year')\n```\n\n\nLooking at the rankings, we can see that the total number of plays doesn't have a massive impact on performance. A song can have five plays or a hundred, and it seems to have a similar outcome in the rankings.\n\nThere is a slight downward trend for songs getting over 120 plays, as these are the absolute most played songs for the year. However, this status still doesn't guarantee a top spot.\n\n## Accounting for Time\n\nA thought I had while looking at the absolute play data is that it disproportionately rewards songs that were released earlier in the year. \n\nTo address this, I have compiled some statistics that consider the peak of the songs, which should eliminate any advantage for being released at the beginning of the year.\n\n```{R plays-vs-success-accounting-for-time}\n\np1 <- combined_data %>%\n  group_by(Song, Artist, rank, Year, week(ymd_hms(timestamp))) %>%\n  summarise(number_of_plays_per_week = n(), .groups=\"drop\") %>%\n  filter(number_of_plays_per_week > 7) %>%\n  group_by(Song, Artist, rank, Year) %>% \n  summarise(peak = n(), .groups=\"drop\") %>%\nggplot( aes(y = rank, x = peak, color = factor(Year)))+\n  geom_point()+\n  scale_color_catppuccin(palette = \"macchiato\") +\n  geom_smooth(color = \"#cad3f5\")+\n  theme(legend.position = 'bottom') +\n  labs(title = \"Weeks > 7 Plays\", y = 'Final Position', x = \"Number of Weeks\", color = 'Year')\n\np2 <- combined_data %>%\n  group_by(Song, Artist, rank, Year, week(ymd_hms(timestamp))) %>%\n  summarise(number_of_plays_per_week = n(), .groups=\"drop\") %>%\n  filter(number_of_plays_per_week > 1) %>% # Removing Join Error\n  group_by(Song, Artist, rank, Year) %>%\n  summarise(peak = max(number_of_plays_per_week), .groups=\"drop\") %>%\nggplot( aes(y = rank, x = peak, color = factor(Year)))+\n  geom_point()+\n  scale_color_catppuccin(palette = \"macchiato\") +\n  geom_smooth(color = \"#cad3f5\")+\n  theme(legend.position = 'bottom') +\n  labs(title = 'Peak Plays Per Week', x = \"Number of Plays\", color = 'Year', y = \"\")\n  \np3 <- combined_data %>%\n  group_by(Song, Artist, rank, Year, week(ymd_hms(timestamp))) %>%\n  summarise(number_of_plays_per_week = n(), .groups=\"drop\") %>%\n  filter(number_of_plays_per_week > 1) %>% # Removing Join Error\n  group_by(Song, Artist, rank, Year) %>%\n  summarise(peak = mean(number_of_plays_per_week), .groups=\"drop\") %>%\nggplot( aes(y = rank, x = peak, color = factor(Year)))+\n  geom_point()+\n  scale_color_catppuccin(palette = \"macchiato\") +\n  geom_smooth(color = \"#cad3f5\")+\n  theme(legend.position = 'bottom') +\n  labs(title = 'Plays Per Week \\n Post Release',  x = \"Number of Plays\", color = 'Year', y = \"\")\n\n\np1\np2\np3\n```\n\nAgain, we can see that there is some useful information, with the peak plays per week showing that songs which have a big peak generally perform well in the final rankings. However, as with the absolute count of plays, there doesn't seem to be a hard and fast rule.\n\n\n# Chart Success\n\nThe ARIA charts collate music sales and streaming data within Australia and produce a weekly list of the top 50 most popular songs. A GitHub user has been kind enough to [compile all of these lists](https://raw.githubusercontent.com/caseybriggs/ARIA-charts/main/single_charts.csv), so we can simply load them and compare the chart results to a song's position in the Hottest 100.\n\n```{R Chart }\n\n# Peak Chart\nchart_summary <- chart_results %>%\n    filter(!is.na(chart_rank)) %>%\n    group_by(Song, Artist, Year, rank.x) %>%\n    summarise(weeks_in_charts = n(),\n    peak_in_carts = min(chart_rank),\n    chart_score = sum(51-chart_rank),\n    .groups=\"drop\") \n\np1 <- chart_summary %>%\nggplot( aes(y = rank.x, x = weeks_in_charts, color = factor(Year)))+\n  geom_point()+\n  scale_color_catppuccin(palette = \"macchiato\") +\n  geom_smooth(color = \"#cad3f5\")+\n  theme(legend.position = 'bottom') +\n  labs(title = 'Weeks In Charts', x = \"Weeks\", color = 'Year', y = \"Hottest 100 Rank\")+\n  scale_y_continuous(limit = c(0, 100)) \n\np2 <- chart_summary %>%\nggplot( aes(y = rank.x, x = peak_in_carts, color = factor(Year)))+\n  geom_point()+\n  scale_color_catppuccin(palette = \"macchiato\") +\n  geom_smooth(color = \"#cad3f5\")+\n  theme(legend.position = 'bottom') +\n  labs(title = 'Peak', x = \"Peak Position\", color = 'Year', y = \"\")+\n  scale_y_continuous(limit = c(0, 100)) \n\np3 <- chart_summary %>%\nggplot( aes(y = rank.x, x = chart_score, color = factor(Year)))+\n  geom_point()+\n  scale_color_catppuccin(palette = \"macchiato\") +\n  geom_smooth(color = \"#cad3f5\")+\n  theme(legend.position = 'bottom') +\n  labs(title = 'Intergral of Chart', x = \"Score\", color = 'Year', y = \"\")+\n  scale_y_continuous(limit = c(0, 100)) \n\np1\np2\np3\n```\n\nThe first thing to note is that these plots are much sparser than the rest. This is because many songs played on Triple J don't make it into the top 50 at all, even though they make it into the Hottest 100.\n\nFor the songs that did make it into the ARIA charts and hung around, they consistently performed well in the countdown. Examples include \"Bad Guy\" by Billie Eilish and \"Dance Monkey\" by Tones and I, which claimed the 1st and 4th spots in their respective years.\n\nHowever, the predictive power of this statistic is again quite limited. Many songs that performed well in the Hottest 100 had poor chart success. For instance, \"Redbone\" by Childish Gambino took the 5th spot in 2015 despite only spending a single week in the charts at rank 42.\n\n\n\n```{R chart-did-it-make-it}\n\nchart_results %>%\n  mutate(chart_rank_na = !is.na(chart_rank)) %>%\n  ggplot(aes(y = rank.x, x = factor(Year), fill = chart_rank_na)) +\n  geom_boxplot(color = 'white') +\n  labs(x = \"Year\", y = \"Hottest 100 Rank\", fill = \"Did it make the Aria Charts\", title = \"Comparing distribution of songs that made the charts vs thoes that didn't\") +\n  theme(legend.position = 'bottom')\n\n```\n\nFrom this chart, we can see that songs that make the charts are outperforming songs that don't. But more importantly, it shows us that making the charts is not a deal-breaker on whether or not a song will perform well in the Hottest 100.\n\n# Timing\n\nAnother thing I wanted to look at was when and how the songs peaked in the play data. Maybe being the popular song would help the song perform around the time that voting is open, which may help with its performance in the final rankings.\n\n```{R week-of-peak}\n\np1 <- combined_data %>%\n  mutate(Week = week(ymd_hms(timestamp)), Year = year(ymd_hms(timestamp))) %>%\n  group_by(Song, Artist, Rank=rank, Year, Week) %>%\n  summarise(plays = n(), .groups = \"drop\") %>%\n  group_by(Song, Artist, Rank, Year) %>%\n  slice_max(order_by = plays, n = 1) %>%\n  ungroup() %>%\nggplot( aes(x = Week, y = Rank) ) +\n  geom_point(aes(color = factor(Year)))+\n  geom_smooth(color = \"#cad3f5\")+\n  scale_color_catppuccin(palette = \"macchiato\", discrete) +\n  labs(title = 'Week of Peak', x = 'Week', y = \"Rank\", color = 'Year')\n\np2 <- combined_data %>%\n  mutate(Week = week(ymd_hms(timestamp)), Year = year(ymd_hms(timestamp))) %>%\n  group_by(Song, Artist, Rank=rank, Year) %>%\n  slice_min(order_by = timestamp, n = 1) %>%\n  ungroup()  %>%\nggplot( aes(x = Week, y = Rank) ) +\n  geom_point(aes(color = factor(Year)))+\n  geom_smooth(color = \"#cad3f5\")+\n  scale_color_catppuccin(palette = \"macchiato\", discrete) +\n  labs(title = 'Week of first play', x = 'Week', color = 'Year', y = \"\")\n\np1\np2\n```\n\nLooking at the above plots, we can see that the week of release or peak really doesn't matter when looking at the final results.\n\nI went on to see if the shape of the peaks looks different for well-performing songs versus poorly performing songs, and again, nothing seems particularly interesting or different between the two.\n\n```{R multiline}\n\np1 <- combined_data %>%\n  mutate(Week = week(ymd_hms(timestamp))) %>%\n  filter(rank < 4 ) %>%\n  group_by(Song, Artist, rank, Year, Week) %>%\n  summarise(plays = n(), .groups=\"drop\") %>%\nggplot( aes(x = Week, y = plays, color = factor(rank), group = interaction(Song, Artist))) +\n  geom_line()+\n  scale_color_catppuccin(palette = \"macchiato\", discrete) +\n  labs(title = 'Position history for Top 3 Tracks', x = 'Week', y = \"Number of Plays\", color = 'Rank')\n\np2 <- combined_data %>%\n  mutate(Week = week(ymd_hms(timestamp))) %>%\n  filter(rank > 96 ) %>%\n  group_by(Song, Artist, rank, Year, Week) %>%\n  summarise(plays = n(), .groups=\"drop\") %>%\nggplot( aes(x = Week, y = plays, color = factor(rank), group = interaction(Song, Artist))) +\n  geom_line()+\n  scale_color_catppuccin(palette = \"macchiato\", discrete) +\n  labs(title = 'Position history for Bottom 3 Tracks', x = 'Week', color = 'Rank', y = \"\")\n  \np1 + p2\n```\n\n# Where we are going wrong\n\nSo it seems that all of my hypotheses are incorrect, and I believe the reason for this is that there is too much variation among the top 100. This is because these songs are already considered the best of the year from a pool of nearly 4000.\n\n```{R overall}\n\ncombined_data_full %>%\n  group_by(Song, Artist, rank, Year) %>%\n  summarise(\n    number_of_plays = n(),\n    .groups = \"drop\"\n  ) %>%\n  mutate(rank_na = ifelse(is.na(rank), \"No\", \"Yes\")) %>%\n  filter(Year < 2023) %>%\n  ggplot(aes(x = factor(Year), y = number_of_plays, fill = rank_na)) +\n  geom_boxplot(color = 'white') +\n  labs(x = \"Year\", y = \"Number of Plays\", fill = 'Did It Make the Top 100?', title = \"Comparing Plays for Songs That did make the 100 vs Didn't\") +\n  theme(legend.position = 'bottom')\n```\n\nLooking at this plot, we can see right away that a song that made the Hottest 100 got more plays than those that didn't, but also that plenty of songs that didn't make the 100 got a comparable number of plays.\n\n# Screw it XGBoost\n\n```{R xdg}\n\n\n\neligible_songs <- combined_plays %>%\n  distinct(Song,  Artist, Year, release_year) %>%\n  filter(Year == release_year) %>%\n  select(-release_year) \n\nplay_stat_time_gt_7 <- combined_plays %>%\n  group_by(Song, Artist, Year, week = week(ymd_hms(timestamp))) %>%\n  summarise(number_of_plays_per_week = n(), .groups=\"drop\") %>%\n  filter(number_of_plays_per_week > 7) %>%\n  group_by(Song, Artist, Year) %>% \n  summarise(weeks_with_more_than_7 = n(), .groups=\"drop\")\n\n  \nplay_stat_time_peak <- combined_plays %>%\n  group_by(Song, Artist, Year, week = week(ymd_hms(timestamp))) %>%\n  summarise(number_of_plays_per_week = n(), .groups = \"drop\") %>%\n  filter(number_of_plays_per_week > 1) %>%\n  arrange(desc(number_of_plays_per_week)) %>%\n  group_by(Song, Artist, Year) %>%\n  summarise(peak_week_JJJ = first(week), peak_plays_JJJ = first(number_of_plays_per_week), .groups = \"drop\")\n\n\nplay_stat_total <- combined_plays %>%\n  filter(release_year >= 2016 & release_year <= 2023) %>%\n  filter(release_year == Year) %>%\n  group_by(Year, Song, Artist) %>%\n  summarize(\n    first_play = ymd_hms(min(timestamp)),\n    total_plays = n(),\n    .groups = \"drop\"\n  ) \n\nchart_stat <- eligible_songs %>%\n  left_join(charts, by = c(\"Song\" = \"Song\", \"Artist\" = \"Artist\", \"Year\" = \"Year\")) %>%\n  filter(Year >= 2016 & Year <= 2023) %>%\n  group_by(Year, Song, Artist) %>%\n  summarize(\n    weeks_in_charts = sum(!is.na(chart_rank), na.rm = TRUE), # Count weeks in charts, excluding NA values\n    peak_in_charts = min(chart_rank, na.rm = TRUE),           # Find the peak position, excluding NA values\n    chart_score = sum(51-chart_rank, na.rm = TRUE),           # Compute the chart score, excluding NA values\n    .groups = \"drop\"\n  ) %>%\n  mutate(\n    weeks_in_charts = ifelse(is.na(weeks_in_charts), NA, weeks_in_charts),\n    peak_in_charts = ifelse(is.na(peak_in_charts) | peak_in_charts == Inf, NA, peak_in_charts), # Use NA instead of Inf when no charts data\n    chart_score = ifelse(is.na(chart_score), NA, chart_score)\n  )\n\nrank_stat <- eligible_songs %>%\n    left_join(combined_results ) %>%\n    mutate(made_100 = !is.na(rank))\n\ndata <- eligible_songs %>%\n    left_join(play_stat_time_gt_7) %>%\n    left_join(play_stat_time_peak) %>%\n    left_join(play_stat_total) %>%\n    left_join(chart_stat) %>%\n    left_join(rank_stat) %>%\n    select(-Country.of.origin)\n    \n\ntraining_data <- data %>% filter(Year > 2015, Year < 2023)\ninferance <- data %>% filter(Year == 2023) %>% \n    select(-rank, -made_100)\n\n\n# Save training data to disk\nsaveRDS(training_data, \"data/training_data.rds\")\nsaveRDS(inferance, \"data/inferance.rds\")\n\n```\n\nI think the direction to go here is to see if we can use ML to find any trends that aren't showing up in the plots.\n\nTo do this, we are going to use XGBoost to train a model to predict the rank of the song using all the stats I wrote out above. The only thing I changed was taking the first play data and setting it to be the month rather than the day to reduce overfitting. For any song that didn't make it into the 100, I set the rank to be 101, as it could be the 101st most popular song that year.\n\n```{R boost-train, results = FALSE}\n\nlibrary(xgboost)\n\nset.seed(64)\n\ntraining_data <- readRDS(\"data/training_data.rds\")\ninferance <- readRDS(\"data/inferance.rds\")\n\n\ndata_cols <- c(\n  \"weeks_with_more_than_7\",\n  \"peak_week_JJJ\",\n  \"peak_plays_JJJ\",\n  \"first_play\",\n  \"total_plays\",\n  \"weeks_in_charts\",\n  \"peak_in_charts\",\n  \"chart_score\"\n)\n\ntraining_data %>% mutate(first_play = month(first_play))\n\ntraining_data[data_cols] <- lapply(training_data[data_cols], as.numeric)\ntraining_data$rank[!training_data$made_100] <- 101\n\n# Prepare the data for XGBoost\ntrain_x <- as.matrix(training_data[, data_cols])\ntrain_y <- lapply(training_data$rank, as.numeric)\n\n# Convert the training data to xgb.DMatrix format\ndtrain <- xgb.DMatrix(data = train_x, label = train_y)\n\n# Set XGBoost parameters\nparams <- list(\n  booster = \"gbtree\",\n  objective = \"reg:squarederror\",\n  max_depth =  6,\n  num_parallel_tree =  200,\n  subsample = 0.8,\n  num_boost_round = 1,\n  eta = 1\n)\n\nxgb_model <- xgboost(\n  params = params,\n  data = dtrain,\n  nrounds = 15,\n  nthread = 8, # Set the number of threads to be used\n  verbose = 1\n)\n\nimportance_matrix <- xgb.importance(feature_names = data_cols, model = xgb_model)\nimportance_df <- as.data.frame(importance_matrix)\n\np1 <-  ggplot(importance_df, aes(x = reorder(Feature, Gain), y = Gain)) +\n  geom_bar(stat = \"identity\") +\n  coord_flip() + # Flip the axes to make it horizontal\n  ylab(\"Gain\") +\n  xlab(\"\")\np2 <-  ggplot(importance_df, aes(x = reorder(Feature, Cover), y = Cover)) +\n  geom_bar(stat = \"identity\") +\n  coord_flip() + # Flip the axes to make it horizontal\n  ylab(\"Cover\") +\n  xlab(\"\")\n\n(p1 + p2) + plot_annotation(title = \"Feature Importance According to XGBoost\")\n\n# Save the trained model to a file for later use\nxgb.save(xgb_model, \"data/xgb_model.bin\")\n\n```\n\nA nice thing about XGBoost is that it can provide insight into the most important factors it uses to predict the results. From the above plots, we can see that the peak of the song on triple J and its total plays contribute significantly to the predictive power. \n\nInterestingly, the chart scores seem to have little effect. However, this can be justified by considering the fact that many songs that make the top 100 never make the charts.\n\nNow that we have the model, we can evaluate its performance in predicting the Hottest 100 by applying it to the play data from 2022.\n\n```{R rebuild}\n\ntest_data = training_data %>% filter(Year == 2022)\n\ntest_x <- as.matrix(test_data[, data_cols])\ntest_y <- lapply(test_data$made_100, as.numeric)\n\npredictions <- predict(xgb_model, test_x)\n\ntest_data$predicted_rank <- predictions\n```\n\n### 2022 Predicted Countdown\n\n```{R rebuild-2022-pred}\n\ntest_data %>% \n  select(Song, Artist, rank, predicted_rank) %>%\n  mutate(predicted_rank = rank(predicted_rank, ties.method = \"first\")) %>%\n  arrange(predicted_rank) %>%  # Sort by predicted_rank\n  select(Song, Artist, Actual = rank) %>%\n  slice_head(n = 20) %>%       # Take the first 20 rows after sorting\n  knitr::kable()\n```\n\n### 2022 Real Countdown\n\n```{R rebuild-2022-real}\n\ntest_data %>% \n  select(Song, Artist, rank, predicted_rank) %>%\n  mutate(predicted_rank = rank(predicted_rank, ties.method = \"first\")) %>%\n  arrange(rank) %>%  # Sort by predicted_rank\n  select(Song, Artist,Predicted =  predicted_rank) %>%\n  slice_head(n = 20) %>%       # Take the first 20 rows after sorting\n  knitr::kable()\n\n```\n\nFrom this, I reckon the model is doing pretty well, so lets have a look at my final predictions for the hottest 100 of 2023.\n\n# My Final Predictions\n\nThe list below seems pretty reasonable, with Doja Cat taking the top spot and my pick for number one, Rush, sitting in 10th. There seems to be a big lean towards pop and a lack of your classic Triple J-style indie rockers, but that might just be the turnout for this year.\n\n```{R 2023, cache = FALSE}\ninferance[data_cols] <- lapply(inferance[data_cols], as.numeric)\ninf <- as.matrix(inferance[, data_cols])\n\npredictions <- predict(xgb_model, inf)\n\ninferance$predicted_rank <- predictions\n\ninferance %>% \n  select(Song, Artist, predicted_rank) %>%\n  mutate(predicted_rank = rank(predicted_rank, ties.method = \"first\")) %>%\n  arrange(predicted_rank) %>%  # Sort by predicted_rank\n  select(Song, Artist) %>%\n  slice_head(n = 100) %>%       # Take the first 20 rows after sorting\n  knitr::kable()\n\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"highlight-style":"../../../themes/code_block.css","output-file":"post.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.43","theme":"../../../themes/theme.scss","title":"Predicting the 2023 Hottest 100","author":"Alfie Chadwick","date":"2024-01-26","lastmod":"`r Sys.Date()`","tags":["Music","Visualizations","ML"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}