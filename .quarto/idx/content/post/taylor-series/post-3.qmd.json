{"title":"Making my ODE solver solve ODEs","markdown":{"yaml":{"title":"Making my ODE solver solve ODEs","author":"Alfie Chadwick","date":"2024-01-12","lastmod":"`r Sys.Date()`","tags":["Calculus","Algebra","Python"]},"headingText":"Simplifying ODEs: Constant-Linear ODEs","containsRefs":false,"markdown":"\n\nAfter writing out the [last post](post-2.html) where I wrote out a python library for using an improved version of Euler's method to solve ODEs. But so far, we haven't been solving ODES, instead we have just been taking an initial value and iterating it over the length of a domain. To To make the ODE estimator work, we need to ensure that the conditions of the ODE are met at each step.\n\n\nODEs are often categorized as linear or non-linear. Linear ODEs take the form $a_0(x)y + a_1(x)y' + ... + a_n(x)y^{n} = b(x)$, with both $a$ and $b$ representing functions of $x$, while  Non-linear equations are all the others. In our solver's context, we'll concentrate on a subset I've termed \"constant-linear\" ODEs, characterized by constant coefficients for $y$ terms and a linear function of $x$ for $b$. Specifically, a constant-linear ODE looks like $a_0y + a_1y' + ... + a_ny^{n} = bx + c$.\n\nThis may seem like a very restrictive requirement, but there are many famous examples of this kind of equation including:\n\n\n1. Simple Harmonic Motion:\n   $$ y'' + \\omega^2 y = 0 $$\n\n2. Radioactive Decay:\n   $$ \\frac{dy}{dt} = -\\lambda y $$\n\n3. RC Circuit Equation:\n   $$ y' + \\frac{1}{RC} y = 0 $$\n\n4. Damped Harmonic Oscillator:\n   $$ y'' + 2\\gamma y' + \\omega_0^2 y = 0 $$\n\n5. Heat Equation (One-Dimensional):\n   $$ u'' - \\frac{1}{\\alpha} u'= 0 $$\n\n6. Exponential Growth or Decay:\n   $$ y' = ky $$\n\n# A Quick Diversion: ODEs in Vector Space\n\nPivoting for a moment, I want to take a quick moment to reframe how we are imagining ODEs. Most of the time, we see ODEs as curves in space and/or time, but I want to reframe them as planes in a vector space.\n\nEach point in this vector space describes the state of a point along a curve, such that a values of the vector give:\n\n$$\\begin{bmatrix}\n1\\\\\nx\\\\\ny(x)\\\\\ny'(x)\\\\\ny''(x)\\\\\n...\\\\\ny^{n}(x)\\\\\n\\end{bmatrix} \n$$\n\nThis means that an ODE can be defined by a plane that contains all the points which meet the requirements of the ODE.\n\nFor example, for the equation $y' = 2x$ this plane looks like:\n\n```{python vector-space, echo = FALSE}\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport mplcatppuccin\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\nmpl.style.use(\"macchiato\")\n\n# Create a grid of values for x and y\nx = np.linspace(0, 10, 100)\ny = np.linspace(0, 100, 100)\nx, y = np.meshgrid(x, y)\n\n# Calculate corresponding z\nz = (2*x)\n\n# Create a figure and a 3D axis\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\nax.plot_surface(x, z,y, alpha = 0.7)\n\n# Set labels\nax.set_xlabel('X')\nax.set_zlabel('Y')\nax.set_ylabel(\"Y'\")\n\n# Show the plot\nplt.show()\n\n```\n\nThen a specific solution to the ODE exists as a curve that sits on this plane. For example, for the IVP that starts at (0,0), the solution follows this curve:\n\n```{python vector-space-line, echo = FALSE}\n\nLx = np.linspace(0, 10, 100)\nLy = np.array([x**2 for x in Lx])\n\n# Create masks for the conditions\nmask = (Lx <= 10) & (Lx >= 0) & (Ly <= 100) & (Ly >= 0)\n\n# Now apply the mask to both arrays to exclude unwanted values\nfiltered_Lx = Lx[mask]\nfiltered_Ly = Ly[mask]\n\nLz = (2*filtered_Lx) +1\n\n# Create a new figure\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d',computed_zorder=False)\n\n# Plot surface and line\nax.plot_surface(x, z,y, zorder=0,alpha = 0.7)\nax.plot(filtered_Lx, Lz, filtered_Ly, color='r',linestyle='dashed' , zorder=1)\n\n\n# Set labels\nax.set_xlabel('X')\nax.set_zlabel('Y')\nax.set_ylabel(\"Y'\")\n\n# Show the plot\nplt.show()\n```\n\n\n## But Why Does This Matter\n\nThe reason that we want to reframe ODEs in this way is because of the following fact:\n\n**For all constant-linear ODEs, we can express the ODE as a matrix such that applying it to any point in the vector space would map any point to a valid point on the curve defined by the ODE**\n\\\n\nLooking at the equations above, these matrices ($T$) are:\n\n\n1. Simple Harmonic Motion:\n$$T = \\begin{bmatrix}\n1 & 0 & 0 & 0 & 0\\\\\n0 & 1 & 0 & 0 & 0\\\\\n0 & 0 & 1 & 0 & 0\\\\\n0 & 0 & 0 & 1 & 0\\\\\n0 & 0 & -\\omega^2 & 0 & 0\\\\\n\\end{bmatrix}\n$$\n\n2. Radioactive Decay:\n$$T = \\begin{bmatrix}\n1 & 0 & 0 & 0\\\\\n0 & 1 & 0 & 0\\\\\n0 & 0 & 1 & 0\\\\\n0 & 0 & -\\lambda & 0\\\\\n\\end{bmatrix}$$\n\n3. RC Circuit Equation:\n$$T = \\begin{bmatrix}\n1 & 0 & 0 & 0\\\\\n0 & 1 & 0 & 0\\\\\n0 & 0 & 1 & 0\\\\\n0 & 0 & \\frac{-1}{RC} & 0\\\\\n\\end{bmatrix}$$\n\n4. Damped Harmonic Oscillator:\n$$T = \\begin{bmatrix}\n1 & 0 & 0 & 0 & 0\\\\\n0 & 1 & 0 & 0 & 0\\\\\n0 & 0 & 1 & 0 & 0\\\\\n0 & 0 & 0 & 1 & 0\\\\\n0 & 0 & -\\omega^2 & -2\\gamma & 0\\\\\n\\end{bmatrix}$$\n\n5. Heat Equation (One-Dimensional):\n$$T = \\begin{bmatrix}\n1 & 0 & 0 & 0 & 0\\\\\n0 & 1 & 0 & 0 & 0\\\\\n0 & 0 & 1 & 0 & 0\\\\\n0 & 0 & 0 & 1 & 0\\\\\n0 & 0 & 0 & \\frac{1}{\\alpha} & 0\\\\\n\\end{bmatrix}$$\n\n6. Exponential Growth or Decay:\n$$T = \\begin{bmatrix}\n1 & 0 & 0 & 0\\\\\n0 & 1 & 0 & 0\\\\\n0 & 0 & 1 & 0\\\\\n0 & 0 & k & 0\\\\\n\\end{bmatrix}$$\n\n## Using these to fit ODEs\n\nNow that we can express the ODEs in the form of a matrix, we can implement these matriexies in the ODE solver package to make the solution fit the ode. \nIt's important here to note that I've diverted from my old definitions of $Y$ here, where the first element of the vector is $y(x)$.\n\nTo make a step in the approximation we use the following equation:\n\n$$ \\begin{bmatrix}\n1 \\\\\nx+h \\\\ \ny(x+h)\\\\\ny'(x+h)\\\\\ny''(x+h)\\\\\n...\\\\\ny^{n}(x+h)\\\\\n\\end{bmatrix} =  S \\cdot \\begin{bmatrix}\n1 \\\\\nx\\\\\ny(x)\\\\\ny'(x)\\\\\ny''(x)\\\\\n...\\\\\ny^{n}(x)\\\\\n\\end{bmatrix}\n\\epsilon $$ \n\nWhere $S$ is:\n$$ \\begin{bmatrix}\n1 & 0 & 0 & 0 & 0 & ... & 0 \\\\\nh & 1 & 0 & 0 & 0 & ... & 0 \\\\\n0 & 0 & 1 & \\frac{h}{1!} & \\frac{h^2}{2!} &  ... & \\frac{h^n}{n!}\\\\\n0 & 0 & 0 & 1 & \\frac{h}{1!} &  ... & \\frac{h^{n-1}}{(n-1)!}\\\\\n0 & 0 & 0 & 0 & 1 &  ... & \\frac{h^{n-2}}{(n-2)!}\\\\\n... & ... & ... & ... &  ... & ...\\\\\n0 & 0 & 0 & 0 & 0 &  ... & 1\\\\\n\\end{bmatrix}$$\n\nWhen making this step, the error in the approximation will move the point away from the plane that contains all valid solutions to the ODE, and therefore we will have to snap it back using one of the transformation matrices ($T$).\n\nImplementing this method in our python library:\n\n```{python solver_code}\ndef expanded_euler(dims, h):\n    step_matrix = np.zeros((dims, dims))\n    for i in range(dims):\n        for j in range(i, dims):\n            # Is 1, and h at j-i =0, 1 respectively\n            step_matrix[i, j] = h ** (j - i) / math.factorial(j - i)\n    expanded_matrix = add_x_and_1(step_matrix, h)\n    return expanded_matrix\n\n\ndef add_x_and_1(original_matrix, h):\n    new_size = len(original_matrix) + 2\n    new_matrix = np.zeros((new_size, new_size), dtype=original_matrix.dtype)\n\n    # Set the 2x2 top left matrix\n    new_matrix[0:2, 0:2] = [[1, 0], [h, 1]]\n\n    # Copy the original matrix to the bottom right of the new matrix.\n    new_matrix[2:, 2:] = original_matrix\n    return new_matrix\n\n\ndef linear(y, step_matrix_generator, transformation_matrix, steps=10, h=0.1):\n    dims = len(y) - 2\n    step_matrix = transformation_matrix @ step_matrix_generator(dims, h)\n    output_list = []\n\n    y_n = y.copy()\n    i = 0\n    while i < steps:\n        y_n = step_matrix @ y_n\n        output_list.append(y_n)\n        i += 1\n```\n\nBind this machinery together, and you get a tool capable of tackling the initial example of $y' = 2x$ passing through the point (0,0):\n\n```{python example-setup, echo = FALSE}\nimport numpy as np\nimport math\n\n\nclass Solution:\n    def __init__(self, input_list: list):\n        solution_list = sorted(input_list, key=lambda x: x[1])\n\n        dims = len(solution_list[0]) - 2\n        self.x = np.array([x[1] for x in input_list])\n\n        value_lists = [[] for _ in range(dims)]\n\n        for v in input_list:\n            for i in range(dims):\n                value_lists[i].append(v[i + 2])\n\n        for i in range(dims):\n            self.__dict__[f\"y_{i}\"] = np.array(value_lists[i])\n\n    def interpolate(self, x, y_n):\n        \"\"\"\n        allows you to get any value from the solution by interpolating the points\n\n        \"\"\"\n        y_values = self.__dict__[f\"y_{y_n}\"]\n\n        x_max_index = np.where(self.x >= x)[0][0]\n        x_min_index = np.where(self.x <= x)[0][-1]\n\n        x_at_x_max = self.x[x_max_index]\n        x_at_x_min = self.x[x_min_index]\n\n        y_at_x_max = y_values[x_max_index]\n        y_at_x_min = y_values[x_min_index]\n\n        slope = (y_at_x_max - y_at_x_min) / (x_at_x_max - x_at_x_min)\n\n        value = y_at_x_min + slope * (x - x_at_x_min)\n        return value\n\ndef linear(y, step_matrix_generator, transformation_matrix, steps=10, h=0.1):\n    dims = len(y) - 2\n    step_matrix = transformation_matrix @ step_matrix_generator(dims, h)\n    output_list = []\n\n    y_n = y.copy()\n    i = 0\n    while i < steps:\n        y_n = step_matrix @ y_n\n        output_list.append(y_n)\n        i += 1\n\n    return Solution(output_list)\n```\n\n```{python example_code}\ninit_y = [1,0,0,0] #[1,x,y,y']\ntransformation_matrix = np.array([\n   [ 1,0,0,0 ],\n   [ 0,1,0,0 ],\n   [ 0,0,1,0 ],\n   [ 0,2,0,0 ]\n])\nsolution = linear(\n    init_y,\n    expanded_euler,\n    transformation_matrix,\n    steps=100, h=0.01)\n```\n\n```{python example_plo, echo=FALSE}\nplt.plot(solution.x, solution.y_0, label='Approximated Solution')\nplt.plot(solution.x, solution.x**2, label='True Solution', linestyle='--')\nplt.xlabel('x') # Label for the x-axis\nplt.ylabel('y') # Label for the y-axis\nplt.grid(True) # Show a grid for better readability\nplt.legend()\nplt.show()\n```\n\n# What's Next?\n\nThis method seems to work pretty well and follows the true solution pretty closely. I'm going to stop here for now but there are many things on my wishlist that I want to build in later posts. This includes:\n\n- Solving IVPs which aren't constant-linear\n- Solving BVPs\n- Applying this method to PDEs\n\nStay tuned for more posts in this series where I try to implement these features into my solver!\n\n","srcMarkdownNoYaml":"\n\nAfter writing out the [last post](post-2.html) where I wrote out a python library for using an improved version of Euler's method to solve ODEs. But so far, we haven't been solving ODES, instead we have just been taking an initial value and iterating it over the length of a domain. To To make the ODE estimator work, we need to ensure that the conditions of the ODE are met at each step.\n\n# Simplifying ODEs: Constant-Linear ODEs\n\nODEs are often categorized as linear or non-linear. Linear ODEs take the form $a_0(x)y + a_1(x)y' + ... + a_n(x)y^{n} = b(x)$, with both $a$ and $b$ representing functions of $x$, while  Non-linear equations are all the others. In our solver's context, we'll concentrate on a subset I've termed \"constant-linear\" ODEs, characterized by constant coefficients for $y$ terms and a linear function of $x$ for $b$. Specifically, a constant-linear ODE looks like $a_0y + a_1y' + ... + a_ny^{n} = bx + c$.\n\nThis may seem like a very restrictive requirement, but there are many famous examples of this kind of equation including:\n\n\n1. Simple Harmonic Motion:\n   $$ y'' + \\omega^2 y = 0 $$\n\n2. Radioactive Decay:\n   $$ \\frac{dy}{dt} = -\\lambda y $$\n\n3. RC Circuit Equation:\n   $$ y' + \\frac{1}{RC} y = 0 $$\n\n4. Damped Harmonic Oscillator:\n   $$ y'' + 2\\gamma y' + \\omega_0^2 y = 0 $$\n\n5. Heat Equation (One-Dimensional):\n   $$ u'' - \\frac{1}{\\alpha} u'= 0 $$\n\n6. Exponential Growth or Decay:\n   $$ y' = ky $$\n\n# A Quick Diversion: ODEs in Vector Space\n\nPivoting for a moment, I want to take a quick moment to reframe how we are imagining ODEs. Most of the time, we see ODEs as curves in space and/or time, but I want to reframe them as planes in a vector space.\n\nEach point in this vector space describes the state of a point along a curve, such that a values of the vector give:\n\n$$\\begin{bmatrix}\n1\\\\\nx\\\\\ny(x)\\\\\ny'(x)\\\\\ny''(x)\\\\\n...\\\\\ny^{n}(x)\\\\\n\\end{bmatrix} \n$$\n\nThis means that an ODE can be defined by a plane that contains all the points which meet the requirements of the ODE.\n\nFor example, for the equation $y' = 2x$ this plane looks like:\n\n```{python vector-space, echo = FALSE}\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport mplcatppuccin\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\nmpl.style.use(\"macchiato\")\n\n# Create a grid of values for x and y\nx = np.linspace(0, 10, 100)\ny = np.linspace(0, 100, 100)\nx, y = np.meshgrid(x, y)\n\n# Calculate corresponding z\nz = (2*x)\n\n# Create a figure and a 3D axis\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\nax.plot_surface(x, z,y, alpha = 0.7)\n\n# Set labels\nax.set_xlabel('X')\nax.set_zlabel('Y')\nax.set_ylabel(\"Y'\")\n\n# Show the plot\nplt.show()\n\n```\n\nThen a specific solution to the ODE exists as a curve that sits on this plane. For example, for the IVP that starts at (0,0), the solution follows this curve:\n\n```{python vector-space-line, echo = FALSE}\n\nLx = np.linspace(0, 10, 100)\nLy = np.array([x**2 for x in Lx])\n\n# Create masks for the conditions\nmask = (Lx <= 10) & (Lx >= 0) & (Ly <= 100) & (Ly >= 0)\n\n# Now apply the mask to both arrays to exclude unwanted values\nfiltered_Lx = Lx[mask]\nfiltered_Ly = Ly[mask]\n\nLz = (2*filtered_Lx) +1\n\n# Create a new figure\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d',computed_zorder=False)\n\n# Plot surface and line\nax.plot_surface(x, z,y, zorder=0,alpha = 0.7)\nax.plot(filtered_Lx, Lz, filtered_Ly, color='r',linestyle='dashed' , zorder=1)\n\n\n# Set labels\nax.set_xlabel('X')\nax.set_zlabel('Y')\nax.set_ylabel(\"Y'\")\n\n# Show the plot\nplt.show()\n```\n\n\n## But Why Does This Matter\n\nThe reason that we want to reframe ODEs in this way is because of the following fact:\n\n**For all constant-linear ODEs, we can express the ODE as a matrix such that applying it to any point in the vector space would map any point to a valid point on the curve defined by the ODE**\n\\\n\nLooking at the equations above, these matrices ($T$) are:\n\n\n1. Simple Harmonic Motion:\n$$T = \\begin{bmatrix}\n1 & 0 & 0 & 0 & 0\\\\\n0 & 1 & 0 & 0 & 0\\\\\n0 & 0 & 1 & 0 & 0\\\\\n0 & 0 & 0 & 1 & 0\\\\\n0 & 0 & -\\omega^2 & 0 & 0\\\\\n\\end{bmatrix}\n$$\n\n2. Radioactive Decay:\n$$T = \\begin{bmatrix}\n1 & 0 & 0 & 0\\\\\n0 & 1 & 0 & 0\\\\\n0 & 0 & 1 & 0\\\\\n0 & 0 & -\\lambda & 0\\\\\n\\end{bmatrix}$$\n\n3. RC Circuit Equation:\n$$T = \\begin{bmatrix}\n1 & 0 & 0 & 0\\\\\n0 & 1 & 0 & 0\\\\\n0 & 0 & 1 & 0\\\\\n0 & 0 & \\frac{-1}{RC} & 0\\\\\n\\end{bmatrix}$$\n\n4. Damped Harmonic Oscillator:\n$$T = \\begin{bmatrix}\n1 & 0 & 0 & 0 & 0\\\\\n0 & 1 & 0 & 0 & 0\\\\\n0 & 0 & 1 & 0 & 0\\\\\n0 & 0 & 0 & 1 & 0\\\\\n0 & 0 & -\\omega^2 & -2\\gamma & 0\\\\\n\\end{bmatrix}$$\n\n5. Heat Equation (One-Dimensional):\n$$T = \\begin{bmatrix}\n1 & 0 & 0 & 0 & 0\\\\\n0 & 1 & 0 & 0 & 0\\\\\n0 & 0 & 1 & 0 & 0\\\\\n0 & 0 & 0 & 1 & 0\\\\\n0 & 0 & 0 & \\frac{1}{\\alpha} & 0\\\\\n\\end{bmatrix}$$\n\n6. Exponential Growth or Decay:\n$$T = \\begin{bmatrix}\n1 & 0 & 0 & 0\\\\\n0 & 1 & 0 & 0\\\\\n0 & 0 & 1 & 0\\\\\n0 & 0 & k & 0\\\\\n\\end{bmatrix}$$\n\n## Using these to fit ODEs\n\nNow that we can express the ODEs in the form of a matrix, we can implement these matriexies in the ODE solver package to make the solution fit the ode. \nIt's important here to note that I've diverted from my old definitions of $Y$ here, where the first element of the vector is $y(x)$.\n\nTo make a step in the approximation we use the following equation:\n\n$$ \\begin{bmatrix}\n1 \\\\\nx+h \\\\ \ny(x+h)\\\\\ny'(x+h)\\\\\ny''(x+h)\\\\\n...\\\\\ny^{n}(x+h)\\\\\n\\end{bmatrix} =  S \\cdot \\begin{bmatrix}\n1 \\\\\nx\\\\\ny(x)\\\\\ny'(x)\\\\\ny''(x)\\\\\n...\\\\\ny^{n}(x)\\\\\n\\end{bmatrix}\n\\epsilon $$ \n\nWhere $S$ is:\n$$ \\begin{bmatrix}\n1 & 0 & 0 & 0 & 0 & ... & 0 \\\\\nh & 1 & 0 & 0 & 0 & ... & 0 \\\\\n0 & 0 & 1 & \\frac{h}{1!} & \\frac{h^2}{2!} &  ... & \\frac{h^n}{n!}\\\\\n0 & 0 & 0 & 1 & \\frac{h}{1!} &  ... & \\frac{h^{n-1}}{(n-1)!}\\\\\n0 & 0 & 0 & 0 & 1 &  ... & \\frac{h^{n-2}}{(n-2)!}\\\\\n... & ... & ... & ... &  ... & ...\\\\\n0 & 0 & 0 & 0 & 0 &  ... & 1\\\\\n\\end{bmatrix}$$\n\nWhen making this step, the error in the approximation will move the point away from the plane that contains all valid solutions to the ODE, and therefore we will have to snap it back using one of the transformation matrices ($T$).\n\nImplementing this method in our python library:\n\n```{python solver_code}\ndef expanded_euler(dims, h):\n    step_matrix = np.zeros((dims, dims))\n    for i in range(dims):\n        for j in range(i, dims):\n            # Is 1, and h at j-i =0, 1 respectively\n            step_matrix[i, j] = h ** (j - i) / math.factorial(j - i)\n    expanded_matrix = add_x_and_1(step_matrix, h)\n    return expanded_matrix\n\n\ndef add_x_and_1(original_matrix, h):\n    new_size = len(original_matrix) + 2\n    new_matrix = np.zeros((new_size, new_size), dtype=original_matrix.dtype)\n\n    # Set the 2x2 top left matrix\n    new_matrix[0:2, 0:2] = [[1, 0], [h, 1]]\n\n    # Copy the original matrix to the bottom right of the new matrix.\n    new_matrix[2:, 2:] = original_matrix\n    return new_matrix\n\n\ndef linear(y, step_matrix_generator, transformation_matrix, steps=10, h=0.1):\n    dims = len(y) - 2\n    step_matrix = transformation_matrix @ step_matrix_generator(dims, h)\n    output_list = []\n\n    y_n = y.copy()\n    i = 0\n    while i < steps:\n        y_n = step_matrix @ y_n\n        output_list.append(y_n)\n        i += 1\n```\n\nBind this machinery together, and you get a tool capable of tackling the initial example of $y' = 2x$ passing through the point (0,0):\n\n```{python example-setup, echo = FALSE}\nimport numpy as np\nimport math\n\n\nclass Solution:\n    def __init__(self, input_list: list):\n        solution_list = sorted(input_list, key=lambda x: x[1])\n\n        dims = len(solution_list[0]) - 2\n        self.x = np.array([x[1] for x in input_list])\n\n        value_lists = [[] for _ in range(dims)]\n\n        for v in input_list:\n            for i in range(dims):\n                value_lists[i].append(v[i + 2])\n\n        for i in range(dims):\n            self.__dict__[f\"y_{i}\"] = np.array(value_lists[i])\n\n    def interpolate(self, x, y_n):\n        \"\"\"\n        allows you to get any value from the solution by interpolating the points\n\n        \"\"\"\n        y_values = self.__dict__[f\"y_{y_n}\"]\n\n        x_max_index = np.where(self.x >= x)[0][0]\n        x_min_index = np.where(self.x <= x)[0][-1]\n\n        x_at_x_max = self.x[x_max_index]\n        x_at_x_min = self.x[x_min_index]\n\n        y_at_x_max = y_values[x_max_index]\n        y_at_x_min = y_values[x_min_index]\n\n        slope = (y_at_x_max - y_at_x_min) / (x_at_x_max - x_at_x_min)\n\n        value = y_at_x_min + slope * (x - x_at_x_min)\n        return value\n\ndef linear(y, step_matrix_generator, transformation_matrix, steps=10, h=0.1):\n    dims = len(y) - 2\n    step_matrix = transformation_matrix @ step_matrix_generator(dims, h)\n    output_list = []\n\n    y_n = y.copy()\n    i = 0\n    while i < steps:\n        y_n = step_matrix @ y_n\n        output_list.append(y_n)\n        i += 1\n\n    return Solution(output_list)\n```\n\n```{python example_code}\ninit_y = [1,0,0,0] #[1,x,y,y']\ntransformation_matrix = np.array([\n   [ 1,0,0,0 ],\n   [ 0,1,0,0 ],\n   [ 0,0,1,0 ],\n   [ 0,2,0,0 ]\n])\nsolution = linear(\n    init_y,\n    expanded_euler,\n    transformation_matrix,\n    steps=100, h=0.01)\n```\n\n```{python example_plo, echo=FALSE}\nplt.plot(solution.x, solution.y_0, label='Approximated Solution')\nplt.plot(solution.x, solution.x**2, label='True Solution', linestyle='--')\nplt.xlabel('x') # Label for the x-axis\nplt.ylabel('y') # Label for the y-axis\nplt.grid(True) # Show a grid for better readability\nplt.legend()\nplt.show()\n```\n\n# What's Next?\n\nThis method seems to work pretty well and follows the true solution pretty closely. I'm going to stop here for now but there are many things on my wishlist that I want to build in later posts. This includes:\n\n- Solving IVPs which aren't constant-linear\n- Solving BVPs\n- Applying this method to PDEs\n\nStay tuned for more posts in this series where I try to implement these features into my solver!\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"highlight-style":"../../../themes/code_block.css","output-file":"post-3.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.43","theme":"../../../themes/theme.scss","title":"Making my ODE solver solve ODEs","author":"Alfie Chadwick","date":"2024-01-12","lastmod":"`r Sys.Date()`","tags":["Calculus","Algebra","Python"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}