{"title":"Making a Python Library to solve differential Equations","markdown":{"yaml":{"title":"Making a Python Library to solve differential Equations","author":"Alfie Chadwick","date":"2023-12-29","lastmod":"`r Sys.Date()`","tags":["Calculus","Algebra","Python"]},"headingText":"First Steps","containsRefs":false,"markdown":"\n\n\nAfter having the initial idea I wrote up in a [previous post](post-1.html), I thought it was a good idea to turn it into a python library so that I can use it as part of my other projects.\n\nIt also gives me a chance to see numerically how well the new method works compared to the Euler method.\n\n\nSo in the last post I set out the method such that:\n\n$$\n\\begin{bmatrix}\ny(x+h)\\\\\ny'(x+h)\\\\\ny''(x+h)\\\\\n...\\\\\ny^{n}(x+h)\\\\\n\\end{bmatrix} =  S \\cdot \\begin{bmatrix}\ny(x)\\\\\ny'(x)\\\\\ny''(x)\\\\\n...\\\\\ny^{n}(x)\\\\\n\\end{bmatrix} + \\epsilon\n$$\n\nIn the Euler method, $S$ is:\n\n$$\n\\begin{bmatrix}\n1 & h & 0 &  ... & 0\\\\\n0 & 1 & h &  ... & 0\\\\\n0 & 0 & 1 &  ... & 0\\\\\n... & ... & ... &  ... & ...\\\\\n0 & 0 & 0 &  ... & 1\\\\\n\\end{bmatrix}\n$$\n\nAnd in the new method I proposed, $S$ is now:\n\n$$\n\\begin{bmatrix}\n1 & \\frac{h}{1!} & \\frac{h^2}{2!} &  ... & \\frac{h^n}{n!}\\\\\n0 & 1 & \\frac{h}{1!} &  ... & \\frac{h^{n-1}}{(n-1)!}\\\\\n0 & 0 & 1 &  ... & \\frac{h^{n-2}}{(n-2)!}\\\\\n... & ... & ... &  ... & ...\\\\\n0 & 0 & 0 &  ... & 1\\\\\n\\end{bmatrix}\n$$\n\nConverting these matrices into python is fairly easy.\n\n```{python defining-step-matrix}\nimport numpy as np\nimport math\n\n\ndef euler(dims, h):\n    # Start with an identity matrix\n    step_matrix = np.identity(dims)\n    # Add in all the h values\n    for i in range(dims - 1):\n        step_matrix[i, i + 1] = h\n    return step_matrix\n\n\ndef expanded_euler(dims, h):\n    step_matrix = np.zeros((dims, dims))\n    for i in range(dims):\n        for j in range(i, dims):\n            # Is 1, and h at j-i =0, 1 respectively\n            step_matrix[i, j] = h ** (j - i) / math.factorial(j - i)\n    return step_matrix\n\n```\n\n# Making a step simulation\n\nNow that we have the stepping matrices, we can use them to iterate from an initial value. All we have to do is generate the stepping matrix for the given problem, and then for each step, we just multiple the previous step by the stepping matrix.\n\n```{python define-step}\ndef IVP(x, y, step_matrix_generator, steps=10, h=0.1):\n    dims = len(y)\n    step_matrix = step_matrix_generator(dims, h)\n    output_dict = {x: y}\n\n    x_n = x\n    y_n = y.copy()\n    i = 0\n    while i < steps:\n        y_n = step_matrix @ y_n\n        x_n += h\n        output_dict[x_n] = y_n\n        i += 1\n\n    return output_dict\n```\n\n# Testing and Comparing the methods\n\nNow we can run the simulations, let's see how good they are.\nSay you throw a ball up in the air and track its vertical position. The path of the ball is described by the equation $y'' = -9.8$. We can know for a fact that the solution to this equation is $\\frac{-9.8}{2}x^2+V_0x+P_0$, where $V_0$ is the initial velocity and $P_0$ is the initial position. So now lets compare the real solutions to the simulations.\n\n```{python gravity-sim }\n# Time starts at 0\nx = 0\n# Start the object moving upwards with a velocity of 10\ny = np.array([0, 10, -9.8])\n\neuler_result = IVP(x, y, euler)\nexpanded_euler_result =IVP(x, y, expanded_euler)\ntrue_result = {x: np.array([\n                    -4.9 * x**2 + 10 * x,\n                    -9.8 * x + 10,\n                    -9.8\n                ]) for x in np.arange(0, 1.1, 0.1)}\n\n```\n\n```{python gravity-sim-plot, echo = FALSE}\n#| echo: false\nimport numpy as np\nimport pandas as pd\nimport mplcatppuccin\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\n\nmpl.style.use(\"macchiato\")\n\n# Extracting data for plotting\neuler_xs = list(euler_result.keys())\neuler_ys = [position[0] for position in euler_result.values()]\n\nexpanded_euler_xs = list(expanded_euler_result.keys())\nexpanded_euler_ys = [position[0] for position in expanded_euler_result.values()]\n\ntrue_xs = list(true_result.keys())\ntrue_ys = [position[0] for position in true_result.values()]\n\n# Plotting the results\nplt.plot(euler_xs, euler_ys, label='Euler Method')\nplt.plot(expanded_euler_xs, expanded_euler_ys, label='Expanded Euler Method')\nplt.plot(true_xs, true_ys, label='True Solution', linestyle=':')\n\nplt.title('Projectile Motion under Gravity')\nplt.xlabel('Time (seconds)')\nplt.ylabel('Height (meters)')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n```\n\nSo from here, we're looking pretty good. The new method is much closer to the true solution than the Euler method in in this scenario. However, when working with numerical methods, it generally isn't too hard to improve the accuracy of the model, but there will be a trade off in computation time. So lets see how much longer it takes to compute the approximation with the expanded method comparing it to the original.\n\n```{python time}\nimport timeit\n\n# Define the step counts to test\nsteps_list = [10, 100, 1000, 10000, 100000]\n\n# Lists to store execution times for each method\neuler_times = []\nexpanded_euler_times = []\n\n# Testing the functions with the different step counts and store the execution times\nfor steps in steps_list:\n    euler_time = timeit.timeit(lambda: IVP(x, y, euler, steps), number=1)\n    expanded_euler_time = timeit.timeit(lambda: IVP(x, y, expanded_euler, steps), number=1)\n\n    euler_times.append(euler_time)\n    expanded_euler_times.append(expanded_euler_time)\n\n```\n\n```{python time-plot}\n\n#| echo: false\n\n# Now we plot the results\nplt.figure(figsize=(10, 5))\n\n# Plot Euler times\nplt.plot(steps_list, euler_times, label='Euler Method', marker='o')\n\n# Plot Expanded Euler times\nplt.plot(steps_list, expanded_euler_times, label='Expanded Euler Method', marker='s')\n\n# Adding labels and title\nplt.xlabel('Number of Steps')\nplt.ylabel('Execution Time (seconds)')\nplt.title('Execution Time for Euler Methods with Different Steps')\nplt.xscale('log')  # Since we have a wide range of steps, a log scale might be more informative\nplt.yscale('log')  # Using a log scale for time to better see differences for small times\nplt.legend()\n\n# Show the plot\nplt.grid(True)\nplt.show()\n```\n\nLooking at this graph, we can see that we're not sacrificing compute time for better accuracy, so this seems like a big win, though I haven't optimised the Euler method that much. But overall, the new method seems to show some promise in approximating differential equations.\n","srcMarkdownNoYaml":"\n\n\nAfter having the initial idea I wrote up in a [previous post](post-1.html), I thought it was a good idea to turn it into a python library so that I can use it as part of my other projects.\n\nIt also gives me a chance to see numerically how well the new method works compared to the Euler method.\n\n# First Steps\n\nSo in the last post I set out the method such that:\n\n$$\n\\begin{bmatrix}\ny(x+h)\\\\\ny'(x+h)\\\\\ny''(x+h)\\\\\n...\\\\\ny^{n}(x+h)\\\\\n\\end{bmatrix} =  S \\cdot \\begin{bmatrix}\ny(x)\\\\\ny'(x)\\\\\ny''(x)\\\\\n...\\\\\ny^{n}(x)\\\\\n\\end{bmatrix} + \\epsilon\n$$\n\nIn the Euler method, $S$ is:\n\n$$\n\\begin{bmatrix}\n1 & h & 0 &  ... & 0\\\\\n0 & 1 & h &  ... & 0\\\\\n0 & 0 & 1 &  ... & 0\\\\\n... & ... & ... &  ... & ...\\\\\n0 & 0 & 0 &  ... & 1\\\\\n\\end{bmatrix}\n$$\n\nAnd in the new method I proposed, $S$ is now:\n\n$$\n\\begin{bmatrix}\n1 & \\frac{h}{1!} & \\frac{h^2}{2!} &  ... & \\frac{h^n}{n!}\\\\\n0 & 1 & \\frac{h}{1!} &  ... & \\frac{h^{n-1}}{(n-1)!}\\\\\n0 & 0 & 1 &  ... & \\frac{h^{n-2}}{(n-2)!}\\\\\n... & ... & ... &  ... & ...\\\\\n0 & 0 & 0 &  ... & 1\\\\\n\\end{bmatrix}\n$$\n\nConverting these matrices into python is fairly easy.\n\n```{python defining-step-matrix}\nimport numpy as np\nimport math\n\n\ndef euler(dims, h):\n    # Start with an identity matrix\n    step_matrix = np.identity(dims)\n    # Add in all the h values\n    for i in range(dims - 1):\n        step_matrix[i, i + 1] = h\n    return step_matrix\n\n\ndef expanded_euler(dims, h):\n    step_matrix = np.zeros((dims, dims))\n    for i in range(dims):\n        for j in range(i, dims):\n            # Is 1, and h at j-i =0, 1 respectively\n            step_matrix[i, j] = h ** (j - i) / math.factorial(j - i)\n    return step_matrix\n\n```\n\n# Making a step simulation\n\nNow that we have the stepping matrices, we can use them to iterate from an initial value. All we have to do is generate the stepping matrix for the given problem, and then for each step, we just multiple the previous step by the stepping matrix.\n\n```{python define-step}\ndef IVP(x, y, step_matrix_generator, steps=10, h=0.1):\n    dims = len(y)\n    step_matrix = step_matrix_generator(dims, h)\n    output_dict = {x: y}\n\n    x_n = x\n    y_n = y.copy()\n    i = 0\n    while i < steps:\n        y_n = step_matrix @ y_n\n        x_n += h\n        output_dict[x_n] = y_n\n        i += 1\n\n    return output_dict\n```\n\n# Testing and Comparing the methods\n\nNow we can run the simulations, let's see how good they are.\nSay you throw a ball up in the air and track its vertical position. The path of the ball is described by the equation $y'' = -9.8$. We can know for a fact that the solution to this equation is $\\frac{-9.8}{2}x^2+V_0x+P_0$, where $V_0$ is the initial velocity and $P_0$ is the initial position. So now lets compare the real solutions to the simulations.\n\n```{python gravity-sim }\n# Time starts at 0\nx = 0\n# Start the object moving upwards with a velocity of 10\ny = np.array([0, 10, -9.8])\n\neuler_result = IVP(x, y, euler)\nexpanded_euler_result =IVP(x, y, expanded_euler)\ntrue_result = {x: np.array([\n                    -4.9 * x**2 + 10 * x,\n                    -9.8 * x + 10,\n                    -9.8\n                ]) for x in np.arange(0, 1.1, 0.1)}\n\n```\n\n```{python gravity-sim-plot, echo = FALSE}\n#| echo: false\nimport numpy as np\nimport pandas as pd\nimport mplcatppuccin\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\n\nmpl.style.use(\"macchiato\")\n\n# Extracting data for plotting\neuler_xs = list(euler_result.keys())\neuler_ys = [position[0] for position in euler_result.values()]\n\nexpanded_euler_xs = list(expanded_euler_result.keys())\nexpanded_euler_ys = [position[0] for position in expanded_euler_result.values()]\n\ntrue_xs = list(true_result.keys())\ntrue_ys = [position[0] for position in true_result.values()]\n\n# Plotting the results\nplt.plot(euler_xs, euler_ys, label='Euler Method')\nplt.plot(expanded_euler_xs, expanded_euler_ys, label='Expanded Euler Method')\nplt.plot(true_xs, true_ys, label='True Solution', linestyle=':')\n\nplt.title('Projectile Motion under Gravity')\nplt.xlabel('Time (seconds)')\nplt.ylabel('Height (meters)')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n```\n\nSo from here, we're looking pretty good. The new method is much closer to the true solution than the Euler method in in this scenario. However, when working with numerical methods, it generally isn't too hard to improve the accuracy of the model, but there will be a trade off in computation time. So lets see how much longer it takes to compute the approximation with the expanded method comparing it to the original.\n\n```{python time}\nimport timeit\n\n# Define the step counts to test\nsteps_list = [10, 100, 1000, 10000, 100000]\n\n# Lists to store execution times for each method\neuler_times = []\nexpanded_euler_times = []\n\n# Testing the functions with the different step counts and store the execution times\nfor steps in steps_list:\n    euler_time = timeit.timeit(lambda: IVP(x, y, euler, steps), number=1)\n    expanded_euler_time = timeit.timeit(lambda: IVP(x, y, expanded_euler, steps), number=1)\n\n    euler_times.append(euler_time)\n    expanded_euler_times.append(expanded_euler_time)\n\n```\n\n```{python time-plot}\n\n#| echo: false\n\n# Now we plot the results\nplt.figure(figsize=(10, 5))\n\n# Plot Euler times\nplt.plot(steps_list, euler_times, label='Euler Method', marker='o')\n\n# Plot Expanded Euler times\nplt.plot(steps_list, expanded_euler_times, label='Expanded Euler Method', marker='s')\n\n# Adding labels and title\nplt.xlabel('Number of Steps')\nplt.ylabel('Execution Time (seconds)')\nplt.title('Execution Time for Euler Methods with Different Steps')\nplt.xscale('log')  # Since we have a wide range of steps, a log scale might be more informative\nplt.yscale('log')  # Using a log scale for time to better see differences for small times\nplt.legend()\n\n# Show the plot\nplt.grid(True)\nplt.show()\n```\n\nLooking at this graph, we can see that we're not sacrificing compute time for better accuracy, so this seems like a big win, though I haven't optimised the Euler method that much. But overall, the new method seems to show some promise in approximating differential equations.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"highlight-style":"../../../themes/code_block.css","output-file":"post-2.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.43","theme":"../../../themes/theme.scss","title":"Making a Python Library to solve differential Equations","author":"Alfie Chadwick","date":"2023-12-29","lastmod":"`r Sys.Date()`","tags":["Calculus","Algebra","Python"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}