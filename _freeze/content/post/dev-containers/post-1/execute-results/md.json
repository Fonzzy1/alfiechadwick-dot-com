{
  "hash": "86a8819e3266d3d2876f8235f5369d71",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"DIY Dev-Containers\"\nauthor: 'Alfie Chadwick'\ndate: '2024-01-07'\nlastmod: \"`r Sys.Date()`\"\nTags: ['Devops','Docker','Vim']\n\n---\n\n\nLike most developers, I spend an inordinate amount of time dealing with my local installations and dependencies. When working on multiple projects, it is not uncommon to encounter conflicting versions of dependencies, and while virtual environments and package managers like Node Package Manager help to mitigate this issue, they often fall short.\n\n# Why we use Dev-Containers\n\nA common solution to these issues is the use of 'dev-containers', which have mostly been popularized by VS Code as a way to have your dependencies exist exclusively inside a Docker container, and then attach an editor to it to make your changes. Sounds great, but unfortunately for me, I have years of using Vim keybindings built into my muscle memory, so there's little chance of me changing my editor. So instead, I thought, why not just rebuild the dev containers for Vim?\n\n# What I want\n\nSo let's quickly scope out this project. In my development containers, I want:\n\n - Isolated environments\n - Vim with my configuration built-in\n - Integration with common CLI tools\n - The ability to use Docker from inside the container\n - Secrets management (not having to re-authenticate all my tools every time I open up a container)\n - Transportability between various Unix machines\n \n# The Beginnings\n\nSo after taking a quick look around my system, I have come up with this initial Dockerfile for my development container:\n\n```dockerfile\nFROM ubuntu as setter_upper\n\nARG DEBIAN_FRONTEND=noninteractive\nENV TZ=Australia/Melbourne\n# Enviroment Installs\nRUN apt-get update && apt-get install -y \\\n   curl git python3 python3-pip apt-transport-https \\\n   ca-certificates software-properties-common  libpq-dev \\\n   build-essential autoconf automake libtool\n\n#Install Docker\nRUN curl -fsSL https://get.docker.com -o install-docker.sh\nRUN sh install-docker.sh\n\n\n# Install GH CLI\nRUN curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \\\n&& chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \\\n&& echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main\" | tee /etc/apt/sources.list.d/github-cli.list > /dev/null \\\n&& apt update \\\n&& apt install gh -y\n\n# git\n#RUN gh auth setup-git\nrun git config --global user.name \"Fonzzy1\"\nrun git config --global user.email \"alfiechadwick@hotmail.com\"\n\n# Set the base work dir\nWORKDIR /src\n\n# Set the mount point as the safe dir\nRUN git config --global --add safe.directory /src\n\n# Vim Setup\nFROM setter_upper as vim\n\n# Enviroment Installs\nRUN apt-get update && apt-get install -y software-properties-common\nRUN add-apt-repository ppa:jonathonf/vim\nRUN apt-get update\n\n# Install the rest of the dependencies\nRUN apt-get install -y \\\n    tig \\\n    fzf \\\n    pkg-config \\\n    texlive \\\n    r-base \\\n    pandoc \\\n    texlive-latex-extra \\\n    libcurl4-openssl-dev \\\n    libssl-dev \\\n    libxml2-dev \\\n    libfontconfig1-dev \\\n    libharfbuzz-dev \\\n    libfribidi-dev \\\n    libfreetype6-dev \\\n    libpng-dev \\\n    libtiff5-dev \\\n    libjpeg-dev \\\n    r-cran-tidyverse \\\n    vim-gtk3\n\n#Install Ctags\nRUN curl -L https://github.com/thombashi/universal-ctags-installer/raw/master/universal_ctags_installer.sh | bash\n\n# Install node\nRUN set -uex\nRUN mkdir -p /etc/apt/keyrings\nRUN curl -fsSL https://deb.nodesource.com/gpgkey/nodesource-repo.gpg.key | gpg --dearmor -o /etc/apt/keyrings/nodesource.gpg\nRUN echo \"deb [signed-by=/etc/apt/keyrings/nodesource.gpg] https://deb.nodesource.com/node_20.x nodistro main\" |  tee /etc/apt/sources.list.d/nodesource.list\nRUN apt-get update && apt-get install nodejs -y;\n\n\n# Install the python packages\nRUN pip install black pipreqs pgcli awscli socli\n\n# Install npm packages\nRUN npm install --save-dev --global prettier\n\n# Download and Install Vim-Plug\nRUN curl -fLo /root/.vim/autoload/plug.vim --create-dirs \\\n    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim\n\n# Install ACT extention\nRUN mkdir -p /root/.local/share/gh/extensions/gh-act\nRUN curl -L -o /root/.local/share/gh/extensions/gh-act/gh-act \\\n    \"https://github.com/nektos/gh-act/releases/download/v0.2.57/linux-amd64\"\nRUN chmod +x /root/.local/share/gh/extensions/gh-act/gh-act\n\n\n# Install R packages, tidyvverse is installed with apt\nRUN R -e  \"install.packages('rmarkdown',  Ncpus = 6)\"\nRUN R -e  \"install.packages('reticulate',  Ncpus = 6)\"\nRUN R -e  \"install.packages('blogdown',  Ncpus = 6)\"\nRUN R -e  \"blogdown::install_hugo()\"\nRUN R -e  \"install.packages('readxl',  Ncpus = 6)\"\nRUN R -e  \"install.packages('knitr',  Ncpus = 6)\"\nRUN R -e  \"install.packages('tinytex',  Ncpus = 6)\"\nRUN R -e  \"install.packages('languageserver',  Ncpus = 6)\"\n\n# Bring in the vim config\nCOPY vim /root/.vim\n#Copy in the dotfiles\nCOPY dotfiles /root\n\n# Install Vim Plugins\nRUN vim +PlugInstall +qall\n\n# Install COC plugins\nRUN mkdir -p /root/.config/coc/extensions && \\\n    echo '{\"dependencies\":{}}' > /root/.config/coc/extensions/package.json && \\\n    grep 'let g:coc_global_extensions' /root/.vim/config/coc.vim | \\\n    sed \"s/.*\\[//; s/\\].*//; s/'//g; s/, /\\n/g\" | \\\n    while read -r extension; do \\\n        echo \"Installing coc extension: $extension\" && \\\n        cd /root/.config/coc/extensions && \\\n        npm install \"$extension\" --install-strategy=shallow --save; \\\n    done\n\nCMD vim\n```\n\nI won't bother explaining most of it since it's really just a heap of install statements, but here are some of the interesting parts:\n\n - I needed to add the WORKDIR to the list of safe directories for git since if I mount the file, the ownership will be wrong.\n - I needed to manually install the gh act extension as you can't do it normally without authenticating with a gh token, something I don't want to do in a public container.\n - Coc Extensions needed to be manually installed to prevent them from installing every time I started the container. Just calling `Vim +CocInstall` didn't work because it's an async process.\n\nSo at this point, I have the first three of my requirements done. Because I'm using Docker, I have an isolated environment every time I boot up the container. By copying over my Vim config files, I have my Vim config baked in, and with some of the commands in the Dockerfile, I am able to have it set up. Finally, by installing a heap of CLI tools, I am able to do most of my work from inside the Vim terminal.\n\n# Docker In Docker\n\nThe next thing to tick off the list is being able to run Docker commands from within the container. Although I have installed Docker, running any Docker command inside the container will say the daemon isn't running.\n\nI could put in a lot of work to give the container the ability to create its own containers, but that would be a real pain. Instead, I can simply mount the Docker daemon onto the container, so that running Docker commands inside the container will invoke the system Docker.\n\nTo accomplish this, I can execute the container using the following command:\n\n```bash\ndocker run -it -v /var/run/docker.sock:/var/run/docker.sock fonzzy1/vim\n```\n\n# Secrets Management\n\nThe next thing to implement is secrets management. I currently have all of these stored in config files in my home directory, which isn't best practice in a Docker container that I want to make public. Instead, I can put all my secrets in a .env file and reference them in the Docker container. This can be done using the --env-file flag when running my Docker container.\n\n# Portability\n\nThe final goal on my list is to make the container portable between my multiple machines. This is achieved through the use of Docker Hub, which will allow me to download the image from Docker Hub. The only other thing I need is to ensure that Docker is set up on the other machine. For this, I have written a quick script to handle the setup process.\n\n\n```{bash, eval=FALSE}\n#!/bin/bash\nset -e\n\n# Dot Progress Indicator\nprogress() {\n    local pid=$2 # PID of the process we're waiting for\n    local text=$1\n    local delay=2 # 2-second delay between dots\n    local dot=\".\"\n\n    printf \"%s:\" \"$text\"\n    while [ \"$(ps a | awk '{print $1}' | grep -w $pid)\" ]; do\n        printf \"%s\" \"$dot\"\n        sleep $delay\n    done\n    printf \" Done!\\n\"\n}\n\nprogress \"Updating package list\" $(sudo apt-get update > /dev/null 2>&1 & echo $!)\n\nprogress \"Installing Useful Packages\" $(sudo apt-get install -y curl > /dev/null 2>&1 & echo $!)\n\nprogress \"Fetching Docker Install Script\" $(curl -fsSL https://get.docker.com -o install-docker.sh > /dev/null 2>&1 & echo $!)\n\nprogress \"Installing Docker\" $(sudo sh install-docker.sh > /dev/null 2>&1 & echo $!)\n\nprogress \"Adding the current user to the Docker group\" $(sudo usermod -aG docker $USER > /dev/null 2>&1 & echo $!)\n\nprogress \"Pulling Image\" docker pull fonzzy1/vim\n\necho \"Setup complete!\"\n```\n\n\n# Wrapping it up\n\nMy so now I have my dev containers running, my only gripe is the stupidly long docker commands that I need to type out to get it running, such as:\n\n\n```{bash, eval=FALSE}\ncurrent_dir=\"$(pwd)\"\ndir_name=\"$(basename \"$current_dir\")\"\n\ndocker run -it \\\n  --env-file ~/.env \\\n  --net=host \\\n  --rm \\\n  -v \"$current_dir:/$(dir_name)\" \\\n  -w \"/$dir_name\" \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  fonzzy1/vim \\\n  /bin/bash -c \"gh auth setup-git; git config --global --add safe.directory /$dir_name; vim\"\n```\n\n\nSo I decided to make this into a little Python script that allows me to quickly run these commands. I also added an integration with `gh` that lets me clone repos in order to edit them on the fly.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n#!/bin/python3\nimport subprocess\nimport argparse\nimport os\n\n\ndef run_local(args):\n    \"\"\"\n    Runs a command in a Docker container with the current directory mounted.\n\n    Args:\n        args (argparse.Namespace): The command-line arguments.\n\n    Returns:\n        None\n    \"\"\"\n    current_dir = subprocess.run([\"pwd\"], capture_output=True, text=True).stdout.strip()\n    dir_name = current_dir.split(\"/\")[-1]  # Get the name of the current directory\n\n    subprocess.run(\n        [\n            \"docker\",\n            \"run\",\n            \"-it\",\n            \"--env-file\",\n            os.path.expanduser(\"~/.env\"),\n            \"--net=host\",\n            \"--rm\",\n            \"-v\",\n            f\"{current_dir}:/{dir_name}\",  # Mount to a directory with the same name\n            \"-w\",\n            f\"/{dir_name}\",  # Set the working directory\n            \"-v\",\n            \"/var/run/docker.sock:/var/run/docker.sock\",\n            \"fonzzy1/vim\",\n            \"/bin/bash\",\n            \"-c\",\n            f\"gh auth setup-git; git config --global --add safe.directory /{dir_name}; vim\",\n        ]\n    )\n\n\ndef run_gh(args):\n    \"\"\"\n    Runs a command for cloning a GitHub repository in a Docker container.\n\n    Args:\n        args (argparse.Namespace): The command-line arguments.\n\n    Returns:\n        None\n    \"\"\"\n    name = args.repo.replace(\"/\", \"-\")\n    repo = args.repo.split(\"/\")[-1] if \"/\" in args.repo else args.repo\n    command = f\"gh auth setup-git; gh repo clone {args.repo} /{repo}; \"\n\n    # Additional git command based on input parameters\n    if args.branch:\n        command += f\"git switch {args.branch}; \"\n    elif args.pullrequest:\n        command += f\"gh pr checkout {args.pullrequest}; \"\n    elif args.checkout:\n        command += f\"git checkout -b {args.checkout}; git push --set-upstream origin {args.checkout}; \"\n\n    # Update submodules if any\n    command += \"git submodule update --init; vim; \"\n\n    # Check for unpushed or uncommitted changes before exiting Vim\n    check_changes_command = ' \\\n        CHANGES=$(git status --porcelain); \\\n        UPSTREAM_CHANGES=$(git cherry -v); \\\n        if [ -n \"$CHANGES\" ] || [ -n \"$UPSTREAM_CHANGES\" ]; then \\\n            vim -c \\':G | only\\'; \\\n        fi'\n\n    # Final combined command\n    final_command = command + check_changes_command\n\n    subprocess.run(\n        [\n            \"docker\",\n            \"run\",\n            \"-it\",\n            \"--env-file\",\n            os.path.expanduser(\"~/.env\"),\n            \"--name\",\n            name,\n            \"--net=host\",\n            \"--rm\",\n            \"-w\",\n            f\"/{repo}\",\n            \"-v\",\n            \"/var/run/docker.sock:/var/run/docker.sock\",\n            \"fonzzy1/vim\",\n            \"/bin/bash\",\n            \"-c\",\n            final_command,\n        ]\n    )\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    subparsers = parser.add_subparsers(title=\"commands\", dest=\"command\")\n\n    local_parser = subparsers.add_parser(\n        \"local\", help=\"Run command for a container with local directory\"\n    )\n    local_parser.set_defaults(func=run_local)\n\n    gh_parser = subparsers.add_parser(\"gh\", help=\"Run command for cloning a repo\")\n    gh_parser.add_argument(\"repo\", help=\"Specify the repository for cloning\")\n    gh_parser.set_defaults(func=run_gh)\n    gh_parser.add_argument(\"-b\", \"--branch\", help=\"The branch to checkout\")\n    gh_parser.add_argument(\n        \"-p\", \"--pullrequest\", help=\"The pull request number to checkout\"\n    )\n    gh_parser.add_argument(\"-c\", \"--checkout\", help=\"Checkout a new branch from main\")\n\n    args = parser.parse_args()\n    args.func(args)\n```\n:::\n\n\n",
    "supporting": [
      "post-1_files"
    ],
    "filters": [],
    "includes": {}
  }
}