{
  "hash": "4b332565312001aaab31c51f8c7c47ea",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"A new way to look at Categories in Hugo Blogs\"\nauthor: \"Alfie Chadwick\"\ndate: \"2023-12-28\"\nlastmod: \"`r Sys.Date()`\"\ntags: ['JavaScript', 'Visualizations']\n---\n\n\n\n\nThis site is built through [blogdown](https://bookdown.org/yihui/blogdown/), which is a marvellous little R package that integrates Hugo sites into a R workflow. A nice thing about Hugo sites are the large number of themes available to quickly integrate with your site to change the vibe. My theme is mostly just a recolored version of the [hello-friend-ng](https://github.com/rhazdon/hugo-theme-hello-friend-ng) theme, using [catppuccin](https://github.com/catppuccin) for the colors.\n\nMy only gripe with the theme is that it uses a default list for all types of content. If you want to look at all the posts, you see a list of posts; for tags, similarly, you get a list of tags.\n\n![How the list of tags looks by default](/post/tag-graph/1.png)\n\n# Looking at the edges\n\nA software that I've always been meaning to use is [obsidian](https://obsidian.md/) which is a note taking and organising software which uses plaintext. One of its features has always really intrigued me, is the graph view which organises all of the notes based on their connections.\n\n![An example of an obsidian graph (Sourced from u/jannesjy on reddit)](https://i.redd.it/49l0t8v09yr91.png)\n\nI thought it would be cool to implement something like this in my Hugo site. Something that lets you not only look at all the tags, but see how they are connected.\n\n# Starting small\n\nBefore making the graph view, I wanted to make something that allows you to see all the posts with two of the tags. That way, when you click on a node or an edge in the graph you can be taken through to see all the posts with the relevant tags. \n\nUnfortunately the scripting language used by Hugo doesn't have this kind of filtering built in. So I have to do it rather un-elegantly in JavaScript. \n\nTo make the linking easier, I added the second tag using the query string so that it can be reached just using a href link.\n\n\n\n\n```{html}\n{{ define \"main\" }}\n<main class=\"posts\">\n  <h1>{{ .Title }}</h1>\n\n  <div id=\"posts-container\">\n    {{ $pages := where .Data.Pages \"Params.tags\" \"intersect\" (slice .Title) }}\n    {{ $paginator := .Paginate $pages }}\n\n    <ul class=\"posts-list\">\n      {{ range $paginator.Pages }}\n      <li class=\"post-item\" data-tags=\"{{  .Params.tags | jsonify }}\">\n        <a href=\"{{ .Permalink }}\" class=\"post-item-inner\">\n          <span class=\"post-title\">{{ .Title }}</span>\n          <span class=\"post-date\">{{ .Date.Format \"January 2, 2006\" }}</span>\n        </a>\n      </li>\n      {{ end }}\n    </ul>\n\n    {{ partial \"pagination-list.html\" . }}\n  </div>\n</main>\n\n<script>\n  document.addEventListener(\"DOMContentLoaded\", function () {\n    const urlParams = new URLSearchParams(window.location.search);\n    let additionalTag = urlParams.get(\"tag\");\n    // Capitalize the first letter of each word\n    function toTitleCase(str) {\n      return str.replace(/\\w\\S*/g, function (txt) {\n        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();\n      });\n    }\n\n    // Update the title with the capitalized query string tag if it exists\n    if (additionalTag) {\n      additionalTag = toTitleCase(additionalTag.replace(/-/g, \" \"));\n      document.querySelector(\"h1\").textContent += \" & \" + additionalTag;\n    }\n\n    // Convert the additionalTag to lowercase and hyphenated format\n    if (additionalTag) {\n      additionalTag = additionalTag.toLowerCase().replace(/\\s+/g, \"-\");\n      console.log(additionalTag);\n\n      const posts = document.querySelectorAll(\".post-item\");\n\n      posts.forEach((post) => {\n        const tagsString = JSON.parse(post.getAttribute(\"data-tags\"));\n\n        // Convert tag string into a lowercase, hyphenated array of tags\n        const tags = tagsString.map((tag) =>\n          tag.trim().toLowerCase().replace(/\\s+/g, \"-\")\n        );\n\n        console.log(tags);\n\n        // If the additional tag is not in the post's tags, hide the post.\n        if (!tags.includes(additionalTag)) {\n          post.style.display = \"none\";\n        }\n      });\n    }\n  });\n</script>\n{{ end }}\n```\n\n\n\n\n# Building the graph\n\nSimilar to the issue with creating the post listing page, constructing the graph requires some rather unwieldy JavaScript to make it work.\n\n## Fetching All the Posts\n\nThe first thing to do is to fetch all the posts from across the site with their tags.\n\n\n\n\n```{JavaScript}\n// Create an array to hold all posts and their details\nvar postsData = [];\n\n// Iterate through each page to collect its title, permalink, and tags\n{{ range .Site.RegularPages }}\n  // Use 'jsonify' to convert tags to a JSON array, if tags are not present, default to an empty array\n  var tags = {{ if .Params.tags }}{{ .Params.tags }}{{ else }}[]{{ end }};\n  postsData.push({\n    title: {{ .Title }},\n    permalink: {{ .RelPermalink }},\n    tags: tags // This is now a real JavaScript array\n  });\n{{ end }}\n\n// Log the posts information in the console as JSON\nconsole.log(postsData);\n\nvar tagsToPosts = {};\n\n// Loop through each post\npostsData.forEach(function(post) {\n  // Loop through each tag in the current post\n  post.tags.forEach(function(tag) {\n    // If the tag hasn't been added to tagsToPosts, initialize it with an empty array\n    if (!tagsToPosts.hasOwnProperty(tag)) {\n      tagsToPosts[tag] = [];\n    }\n    // Add the current post to the array for this tag\n    tagsToPosts[tag].push({\n      title: post.title,\n      permalink: post.permalink\n    });\n  });\n});\n```\n\n\n\n\n## Invert the keys of the list\n\nNow that there is a list of posts with there tags, we can now invert the list so that we have all the tags with their posts.\n\n\n\n\n```{JavaScript}\nvar tagsToPosts = {};\n\n// Loop through each post\npostsData.forEach(function(post) {\n  // Loop through each tag in the current post\n  post.tags.forEach(function(tag) {\n    // If the tag hasn't been added to tagsToPosts, initialize it with an empty array\n    if (!tagsToPosts.hasOwnProperty(tag)) {\n      tagsToPosts[tag] = [];\n    }\n    // Add the current post to the array for this tag\n    tagsToPosts[tag].push({\n      title: post.title,\n      permalink: post.permalink\n    });\n  });\n});\n// Log the new tags to posts dictionary\nconsole.log(tagsToPosts);\n```\n\n\n\n\n## Make a matrix of connections\n\nWith the list of tags, we can now make a matrix showing all of the connections between the tags. This is really inefficient but it works well enough that I don't think it requires too much optimisation.\n\n\n\n\n```{JavaScript}\n// Get all unique tags\nvar uniqueTags = Object.keys(tagsToPosts);\n\n// Initialize the matrix with zeros\nvar tagMatrix = uniqueTags.map(() => uniqueTags.map(() => 0));\n\n// Function to check the intersection of posts for two tags\nfunction getSharedPostsCount(tagA, tagB, tagsToPosts) {\n  var postsA = tagsToPosts[tagA];\n  var postsB = tagsToPosts[tagB];\n  var shared = postsA.filter(postA => postsB.some(postB => postA.permalink === postB.permalink));\n  return shared.length;\n}\n\n// Populate the matrix with shared post counts\nfor (let i = 0; i < uniqueTags.length; i++) {\n  for (let j = i; j < uniqueTags.length; j++) {\n    // We only need to calculate the upper triangular matrix due to symmetry\n    var sharedCount = getSharedPostsCount(uniqueTags[i], uniqueTags[j], tagsToPosts);\n    tagMatrix[i][j] = sharedCount;\n    tagMatrix[j][i] = sharedCount; // The matrix is symmetric so we mirror the count\n  }\n}\n\n// Log the matrix\nconsole.log(tagMatrix);\n```\n\n\n\n\n## Build the graph\n\nBuilding the graph was honestly one of the easiest parts of this project. The [d3js](https://d3js.org/) library has an object called a force directed graph, has most of the features I would want baked in.\n\nThe only interesting thing I've done here is add in on-click links to the nodes and the edges that allow you to click through to see the relevant posts.\n\n\n\n\n```{JavaScript}\nvar width = window.innerWidth;\nvar height = window.innerHeight;\n\n// Setup the window\nvar svg = d3.select(\"body\")\n  .append(\"svg\")\n  .attr(\"width\", width)\n  .attr(\"height\", height)\n  .style(\"display\", \"block\")\n  .style(\"margin\", \"auto\");\n\nvar nodeRadius = 60;\nvar collisionRadius = nodeRadius * 2;\n\n// Setup the simulation\nvar simulation = d3.forceSimulation(nodes)\n  .force(\"link\", d3.forceLink(links)\n    .id(d => d.id)\n    .distance(200)\n    .strength(d => 0.1 * d.value))\n  .force(\"charge\", d3.forceManyBody()\n    .strength(d => -500 * (d.value + 1)))\n  .force(\"center\", d3.forceCenter(width / 2, height / 2))\n  .force(\"collision\", d3.forceCollide(collisionRadius))\n  .alphaDecay(0.01);\n\n// System for dragging\nvar dragHandler = d3.drag()\n  .on(\"start\", function(d) {\n    if (!d3.event.active) simulation.alphaTarget(0.3).restart();\n    d.fx = d.x;\n    d.fy = d.y;\n  })\n  .on(\"drag\", function(d) {\n    d.fx = d3.event.x;\n    d.fy = d3.event.y;\n  })\n  .on(\"end\", function(d) {\n    if (!d3.event.active) simulation.alphaTarget(0);\n    d.fx = null;\n    d.fy = null;\n  });\n\n// Draw the line between the nodes\nvar link = svg.append(\"g\")\n  .attr(\"class\", \"links\")\n  .selectAll(\"line\")\n  .data(links)\n  .enter().append(\"line\")\n  .attr(\"stroke-width\", d => Math.sqrt(d.value) + 10)\n  .attr(\"stroke\", \"#cad3f5\")\n  .on(\"click\", function(d) {\n    console.log(`Link clicked between ${d.source.id} and ${d.target.id}`);\n    let tagName1 = d.source.id.replace(/\\s+/g, '-').toLowerCase();\n    let tagName2 = d.target.id.replace(/\\s+/g, '-').toLowerCase();\n    window.location.href = `/tags/${tagName1}?tag=${tagName2}`;\n  });\n\nvar colors = [\n  '#f4dbd6',\n  '#b7bdf8',\n  '#ed8796',\n  '#f5a97f',\n  '#eed49f',\n  '#a6da95',\n  '#8bd5ca',\n  '#8aadf4',\n  '#c6a0f6',\n  '#f0c6c6'\n];\n\nfunction getRandomColor() {\n  return colors[Math.floor(Math.random() * colors.length)];\n}\n\n\n\n// Make the nodes\nvar node = svg.append(\"g\")\n  .attr(\"class\", \"nodes\")\n  .selectAll(\"circle\")\n  .data(nodes)\n  .enter().append(\"circle\")\n  .on(\"click\", function(d) {\n    let tagName = d.id.replace(/\\s+/g, '-').toLowerCase();\n    window.location.href = `/tags/${tagName}`;\n  })\n  .attr(\"r\", nodeRadius)\n  .attr(\"fill\", function(d) { return getRandomColor(); });\n\nnode.append(\"title\")\n  .text(d => d.id);\n\nsimulation\n  .nodes(nodes)\n  .on(\"tick\", ticked);\n\nsimulation.force(\"link\")\n  .links(links);\n\ndragHandler(node);\n\n// Wirite out the labels\nvar labels = svg.append(\"g\")\n  .attr(\"class\", \"labels\")\n  .selectAll(\"text\")\n  .data(nodes)\n  .enter().append(\"text\")\n  .text(d => d.id)\n  .style(\"fill\", \"24273a\")\n  .style(\"text-anchor\", \"middle\")\n  .style(\"dominant-baseline\", \"central\")\n  .on(\"click\", function(d) {\n    let tagName = d.id.replace(/\\s+/g, '-').toLowerCase();\n    window.location.href = `/tags/${tagName}`;\n  });\n\n// Update function\nfunction ticked() {\n  link\n    .attr(\"x1\", d => d.source.x)\n    .attr(\"y1\", d => d.source.y)\n    .attr(\"x2\", d => d.target.x)\n    .attr(\"y2\", d => d.target.y);\n\n  node\n    .attr(\"cx\", d => d.x)\n    .attr(\"cy\", d => d.y);\n\n  labels\n    .attr(\"x\", d => d.x)\n    .attr(\"y\", d => d.y);\n}\n```\n\n\n\n\n\nIf you want to check out the code for this in full, you can get the [post page](https://github.com/Fonzzy1/alfiechadwick-dot-com/blob/main/themes/hello-friend-ng/layouts/taxonomy/tag.html) and the [graph page](https://github.com/Fonzzy1/alfiechadwick-dot-com/blob/main/themes/hello-friend-ng/layouts/taxonomy/tag.terms.html) from github, or checkout the graph in its current state [here](/tags/).\n\n",
    "supporting": [
      "post_files"
    ],
    "filters": [],
    "includes": {}
  }
}